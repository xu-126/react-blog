/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50731
 Source Host           : localhost:3306
 Source Schema         : react_blog

 Target Server Type    : MySQL
 Target Server Version : 50731
 File Encoding         : 65001

 Date: 08/04/2021 11:35:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article_content
-- ----------------------------
DROP TABLE IF EXISTS `article_content`;
CREATE TABLE `article_content` (
  `id` int(3) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `content` text,
  `introduce` varchar(255) DEFAULT NULL,
  `release_time` bigint(13) DEFAULT NULL,
  `visit_count` int(11) NOT NULL,
  `type_id` int(11) NOT NULL,
  `update_time` bigint(13) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_content
-- ----------------------------
BEGIN;
INSERT INTO `article_content` VALUES (1, 'VSCode常用插件和技巧教程', '  VSCode 想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。  \n## P01：VSCode实现毛玻璃效果\n\n技术胖虽然长的难看，但绝对是喜欢漂亮人和物的，比如说小姐姐。那作为一个前端程序员，肯定也会让自己的VSCode越漂亮越好。这个文章我就介绍一下，如何让VSCode拥有漂亮的毛玻璃效果。\n\n毛玻璃的朦胧美，就仿佛美女穿了黑色的丝袜，非常的诱人心智。\n\nVibrancy\n安装并运行插件\n\n其实要实现这个效果，只需要下载一个插件就可以解决，这个插件就是 Vibrancy。\n\n打开VSCode，然后点击插件栏，搜索插件Vibrancy，搜索到之后，点击install进行安装。\n\nVibrancy\n\n安装好主体后，你需要按F1键,打开命令输入框，然后输入Reload Vibrancy后回车。如果不起作用，你就重新启动一下VSCode.\n\n需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。\n插件设置\n\n这个插件还支持透明度和两款主题样式的设置。设置方法是在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions ，然后再找到Vibrancy Effect进行设置。\n\n一共有三项设置：\n\n    Opacity：透明度设置，这个数值默认为-1，你可以输入自己喜欢的值0-1之间，比如0.8.\n    Theme： 毛玻璃的样式设置，一共有三个样式可选，以后可能还会增加。\n    Type： 这个有很多选项，你可以具体进行测试。\n\n## P02：VSCode里直接预览效果\n\n如果你没有双屏显示器，又不想来回切换窗口，而是直接在VSCode里进行预览，这简直太方便了，剩下的时间看个岛国小电影或者玩两把守望屁股他不香吗?\n\n来来来，快点开始吧，妹子和游戏都在向我招手。\n\nBrowser Preview\n安装Browser Preview\n\n打开插件管理，然后搜索Browser Preview插件，直接进行安装。\n\nBrowser Preview\n\n安装完成后，在Bar上多出一个图标，点击图标就可以在VSCode里打开浏览器了。\n修改默认打开网址\n\n现在的默认地址确实烦人，每次都要重新输入，这是一个有贞操的程序员所不能忍受的。所以我们按住ctrl + ,打开设置，然后找到Extensions,再找到Browser Preview,找到Start Url写上你默认打开的地址就可以了。\n## P03：VSCode一个插件让你的代码更职业\n\n你有没有怀疑过你写的JavaScript代码？如何让自己的代码更专业？VSCode中的JavaScript Booster可以快速提升你的代码专业度。\n\n插件安装完成，不用配置任何东西，就可以使用了。\n\nJavaScript Booster\n插件的基本使用\n\n插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码。\n\n比如我们新建一个js文件，写如下代码：\n\nvar string1= \'jspang.com\';\n\n这时候我们点击var 关键词，JavaScript Booster就会给我们出现黄色小灯泡，我们点击黄色小灯泡后，它会提示我们var可以换成const.直接点击更换。\n\n更换后的代码变成了这个样子。\n\nconst string1= \'jspang.com\';\n\n再比如你写了这样一段代码：\n\nconst gogo = function(str){\n    return \'hi\'+ str\n}\n\n这时候你点击function后，它会出现黄色警告，点击后会提示改为箭头函数，再次点击hi，又会出现警告，说可以使用模板字符串。两次点击后就代码就变成了下面的样子。\n\nconst gogo = str => {\n    return `hi${str}`;\n}\n\n再比如，你要去象牙山洗脚城去大宝剑一下的时候，如果你选择32号就是“刘英”为你服务，如果你选择其它的就是“谢大脚”为你服务。\n\nlet a = 32\nlet str1=\'jspang\'\nif(a===32){\n    str1=\'刘英\'\n}else{\n    str1=\'谢大脚\'\n}\n\n这时候你点击if会提示你改为三元运算符的形式，就变成了这样。\n\nlet a = 32\nlet str1=\'jspang\'\nstr1 = a===32 ? \'刘英\' : \'谢大脚\';\n\n这个插件还有很多转换方式，你可以在写完代码后都点击点击，这样慢慢的你代码水平就会提高。\n## P04：VSCode界面透明插件 程序员上班看片神器\n上次介绍了一个毛玻璃插件，小伙伴都说不太好用，那我这个文章就介绍我的一个我的御用插件`Windows opacity`。有了这个插件，从此上班偷偷看看小姐姐，偷偷看视频时完全可以的。\n\nWindows opacity\n安装并运行插件\n\n安装这个插件是非常简单的，只要打开VSCode,然后点击插件Icon图标，进入插件，在搜索栏上搜索windos opacity,然后找到如图插件，进行安装就可以了。\n\nWindows opacity\n\n安装好后，需要重启一下VSCode，就可以出现透明效果了。\n插件的设置\n\n现在的透明度可能看片还是有一点问题的，那我们就把透明度调的高一点。在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions选项卡，然后找到Windows opacity进行设置。\n\n这里边只有一个设置项，就是Opacity，也就是我们要设置的透明度，值从0-255,数值越小透明度越高，数值越大透明度越低。我一般摸鱼的透明度在230左右，再小就容易被发现了。', '想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。', 1584266350598, 1876, 4, 1587644746000);
INSERT INTO `article_content` VALUES (2, 'Navicat连接腾讯云服务器上的数据库', '## 下面介绍Navicat连接腾讯云服务器上的数据库的两种方法：\n\n## 方法一：【不需要修改相关远程客户端连接权限】\n\n点击安装好的桌面navicat图标，进入后如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214202494-819455691.png)\n\n连接方法：ssh中输入自己服务器的外网ip地址，登录服务器账号和密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214402984-1454339889.png)\n\n \n\n再设置常规属性中，数据库的连接，主机填localhost，因为mysql安装在了本地服务器上，然后填入mysql的用户名及密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214519764-88496090.png)\n\n \n\n \n\n## 方法二：【修改相关MySQL远程客户端连接权限】\n\n下面命令最好在root用户下执行使用：【否则可能会一些文件修改权限受阻问题，需要手动修改用户对文件的使用权限】\n\n#### 1、我们需要更改 3306端口，查看3306 端口是否对外开放，而一般MySQL 默认情况下是不开放对外访问功能的。\n\n使用下面语句进行查询：\n\n \n\n```\n# netstat -an | grep 3306\n```\n\n如果查询结果如下，则需要我们更改 MySQL 配置文件。\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214621204-572794575.png)\n\n查询结果可以看出，MySQL的3306端口只是监听本地的连接，这样就阻碍了外部IP对该数据库的访问，修改 MySQL 配置文件：\n\n```\n# /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在MySQL配置文件中找到  bind-address = 127.0.0.1 这一行\n\n将bind-address = 127.0.0.1 这行注释掉或者改为你想要使用的客户端主机 ip。如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214704648-229822164.png)\n\n \n\n \n\n这样，我们的 MySQL 远程访问端口就开启成功了。\n\n \n\n#### 2、我们进入 MySQL 命令界面，运行下列SQL 语句：\n\n \n\n使用下面命令先在服务器终端上登录mysql的root用户\n\n \n\n```\n# mysql -uroot -p\n```\n\n \n\n然后输入root用户密码就可以登录mysql了\n\n \n\n使用下面命令切换为使用mysql数据库\n\n \n\n```\nmysql> use mysql; \n```\n\n \n\n使用下面命令查看用户是否具有访问权限：\n\n \n\n```\nmysql> select user, host from user;\n```\n\n \n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214823443-1521450522.png)\n\n \n\n上面显示root用户只用访问本地的权限，我们需要通配符 % 来修改 root 用户对应的 host 字段，使其具有访问所有 ip 地址的权限：\n\n```\nmysql> update user set host = \'%\' where user = \'root\';\n```\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214943424-1543189887.png)\n\n \n\n如果抛出如下异常：\n\n```\nDuplicate entry \'%-root\' for key \'PRIMARY\'\n```\n\n说明有多个root用户纪录在user表中了，我们重新执行下面命令就可以看到字段 host 的 % 值：\n\n```\nmysql> select host from user where user = \'root\';\n```\n\n我们执行：\n\n```\nmysql> flush privileges;\n```\n\n刷新一下 MySQL 的系统权限相关表。\n\n下面还要确认的一件事就是确认客户端用户是否具有权限，我们给与他们相应的访问权限：\n\n```\nmysql> grant all privileges on *.* to username@\"%\" identified by \"password\";\n```\n\n最后退出mysql重启一下 MySQL 服务：\n\n```\nmysql> exit;   //退出mysql\n#sudo mysql restart   //重启mysql服务\n```\n\n#### 3、服务端设置好了，我们在 Navicat 客户端设置一下连接：\n\n打开 Navicat软件，点击左上方的 \"连接\"，设置一下数据库的连接名，服务器外网ip地址，mysql用户名及密码等，\n\n点击测试连接成功后再点击确定按钮便能在 Navicat 中远程操作服务器上的 MySQL 了。\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705215031893-1645905718.png)\n\n \n\n \n\n到这里，Navicat连接腾讯云服务器上的数据库的两种方法就结束了，希望可以帮助大家。。。', '介绍Navicat连接腾讯云服务器上的数据库的两种方法', 1586268227000, 2078, 4, 1586268733000);
INSERT INTO `article_content` VALUES (3, 'js数组【续】(相关方法)', '## 一、数组的栈，队列方法【调用这些方法原数组会发生改变】\n\n```\n    var arr = [2,3,4,5,6];\n```\n\n1.栈 LIFO (Last-In-First-Out)\n\n a、push() 可接受任意类型的参数，将它们逐个添加到数组的末尾。【返回数组的长度】\n\n```\n    console.log(arr);  //[2,3,4,5,6]\n    console.log(+arr.push(7)); //返回添加数据后数组的长度：6\n    console.log(arr);  //[2,3,4,5,6,7]\n```\n\nb、pop() 从数组的末尾移除最后一项，减少数组的length值。【返回移除的项】\n\n```\n    console.log(arr.pop()); //取出栈顶元素并返回该栈顶元素值：7\n    console.log(arr);  //[2,3,4,5,6]\n```\n\n2.队列 FIFO (First-In-First-Out)\n\na、shift() 移除数组中的第一个项，同时将数组的长度减一。【返回移除的项】\n\n```\n    console.log(arr.shift()); //hello\n    console.log(arr); //[2,3,4,5,6]\n```\n\nb、unshift() 在数组的前端添加任意个项。【返回数组的长度】\n\n```\n    console.log(arr.unshift(\'hello\')); //6\n    console.log(arr); //[\'hello\',2,3,4,5,6]\n```\n\n## 二、数组的排序方法【reverse()方法、sort()方法】(原数组发生改变)\n\nvar arr = [23,56,12,43,6,23,26];\n\n1、reverse()方法：【对数组项进行反转】\n\n```\n    console.log(arr);\n    //反转 翻转 reverse  改变原数组\n    console.log(arr.reverse());\n    console.log(arr);\n```\n\n2、sort()方法【数组排序,返回排序后的数组】\n\na、sort()不带参数默认为升序\n\n```\n    console.log(arr.sort()); //按照字符串ASSIC码形式比较\n```\n\nb、sort()带指定排序函数\n函数返回值：\n    正值：交换\n    负值：不交换\n\n```\n    console.log(arr.sort(com));\n    console.log(arr);\n    function com(a,b){\n        //return a-b;  //升序\n        //负数a,b不发生交换 a b  a<b 负值  不交换;  a b  a<b  升序排列\n        //正数数a,b不发生交换   a b  a>b 正值  交换;   b  a   b<a  升序排列\n\n        //return b-a;  //降序\n\n        //升序\n        if(a<=b){\n                return -1;  //负数不发生交换\n        }else{\n                return 1;  //正数发生交换\n        }\n```\n\n3、查找最高(最低)的数组值\n\na.使用sort()方法先进行排序，然后再在排好序的数组中取值\nb.使用Math.max.apply()和Math.min.apply()方法\n\n```\n    Math.max.apply(null,array);　　//获取array数组中的最大值\n    Math.min.apply(null,array);　　//获取array数组中的最小值\n```\n\n## 三、截取方法：\n\n1、数组拼接：concat()方法 【不改变原数组】\n\n先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，返回副本数组。\neg:\n\n```\n    var arr = [3,4,5,2,4];\n    var arr2 = [1,2,3,4,5];\n\n    var result = arr.concat(arr2);\n    console.log(arr);    //[3,4,5,2,4]\n    console.log(result);    //[3,4,5,2,4,1,2,3,4,5]\n\n    var result2 = arr.concat(\'hello\');\n    console.log(result2);    //[3,4,5,2,4,\'hello\']\n```\n\n2、数组切割：slice()方法 【不改变原数组】\n\nslice(返回项的起始位置，结束位置);\n一个参数：从该参数指定的位置开始，到当前数组末尾的所有项。\n两个参数：起始到结束之间的项，但是不包含结束位置的项。\neg:\n\n```\n    //参数是一个为从开始位置截取到末尾；参数是两个的，截取部分为开始位置到结束位置不包括结束位置的值\n    //返回截取部分的值,不改变原数组\n    var arr = [123,34,5,67,3,6,8];\n    var result = arr.slice(2);\n    console.log(result);  //[5,67,3,6,8]\n    console.log(arr);  //[123,34,5,67,3,6,8]\n\n    var result2 = arr.slice(2,4);\n    console.log(result2); //[5,67]\n```\n\n3、splice() 【改变原数组】\n\n向数组的中部插入数据将始终返回一个数组，该数组中包含从原始数组中删除的项。\n删除：指定一个参数(删除的开始的位置)【删除该参数索引及后面的所有元素】；指定两个参数(删除的起始位置，要删除的项数) 【返回删除的元素组成的数组】\n插入：指定三个参数(起始位置，0，要插入的项任意数量的项) \n替换：指定三个参数(起始位置，要删除的项数，要插入的任意数量的项)\neg:\n\n```\n    //删除\n    var arr = [32,4,9,3,0];\n    var result = arr.splice(1,3);\n    console.log(result);  //[4,9,3]\n    console.log(arr); //[32,0]\n\n    //插入\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,0,\'hello\',\'sss\');\n    console.log(arr);  //[32,\'hello\',\'sss\',4,9,3,0]\n\n    //替换\n    //从索引位置为1的删除两项后在开始位置处再插入一些元素\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,2,1,2);\n    console.log(arr); //[32,1,2,3,0]\n```\n\n## 四、索引方法\n\nindexOf lastindexOf 返回索引或-1\nvar arr = [2,5,67,\'2\',3,2,45];\n\n1、indexOf() \n\n从数组开头向后查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    //参数：要查找的元素   开始查找的位置\n    console.log(arr.indexOf(2)); //0\n    console.log(arr.indexOf(2,1)); //5\n    console.log(arr.indexOf(22)); //-1\n```\n\n2、lastIndexOf() \n\n从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    console.log(arr.lastIndexOf(2));  //5\n    console.log(arr.lastIndexOf(2,3)); //0\n```\n\n3.常用于判断数组中是否含有该元素\n\n```\n    if(arr.indexOf(2) != -1){ }\n```\n\n## 五、迭代方法\n\n参数： 每一项上运行的函数，运行该函数的作用域对象（可选）\n\n1、every() \n\n对数组中的每一运行给定的函数参数，如果该参数函数对每一项都返回true,则该函数返回true\neg:\n\n```\n    var arr = [23,45,1,4,3,45,7];\n    var result = arr.every(function(item,index,arr){\n        console.log(this); //{}\n        return item>20;\n    },{});\n    console.log(result); //false\n```\n\n2、some(),3、filter(),4、map()使用的数组如下：\n\n```\nvar stus = [\n        {\n                name:\'zhangsan\',\n                age:20\n        },{\n                name:\'lisi\',\n                age:13\n        },{\n                name:\'wangwu\',\n                age:12\n        }\n];\n```\n\n2、some() \n\n对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true\neg：\n\n```\n    //判断是否有未成年人，有返回true，否则返回：false\n    var result = stus.some(function(item,index,arr){\n         return item.age<18\n    });\n    console.log(result); //true\n```\n\n3、filter() \n\n对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组\neg：\n\n```\n    //filter\n    //过滤出来所有成年人\n    var result = stus.filter(function(item,index,arr){\n        return item.age>18;\n    });\n    console.log(result);\n\n    //查找所有未成年人的名字\n    //先过滤出所有未成年人再映射出符合条件人名字\n    var result = stus.filter(function(item,index,arr){\n        return item.age<18;\n    }).map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n```\n\n4、map()\n\n对数组中的每一元素运行给定的函数,返回每次函数调用的结果组成的数组\n\n```\n    //map\n    //查找处所有人的名字,返回数组\n    var result = stus.map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n    var result = stus.map(function(item,index,arr){\n        return item.age*2;\n    });\n    console.log(result);\n```\n\n5、forEach() \n\n对数组中的每一元素运行给定的函数,没有返回值，常用来遍历元素\n\n```\n    //数组的遍历\n    var arr = [{\n        name:\'zhangsan\'\n    },{\n        name:\'lisi\'\n    },{\n        name:\'terry\'\n    }];\n    //向数组各元素对象中添加age属性\n    var ageInit = 10;\n    arr.forEach(function(item,index,arr){\n        item.age = ageInit++;\n    });\n    console.log(arr);\n```\n\n ', 'js数组中一些常用的方法基本使用', 1584547200000, 2342, 3, 1585017659000);
INSERT INTO `article_content` VALUES (4, 'js正则表达式【续】(相关字符的解释含义)', '## 1、字符类\n\n[直接量] \n. (点号，小数点) 匹配任意单个字符，但是行结束符除外  \n\\d 　　匹配一个0-9之间的阿拉伯数字。等价于[0-9]  \n\\D 　   匹配任意一个不是0-9之间阿拉伯数字的字  符。等价于[^0-9]。   \n\\w 　   匹配任意一个字母、数字或下划线的字符。等价于 [A-Za-z0-9_]。   \n\\W　   匹配任意一个不是字母、数字或下划线的字符。等价于 [^A-Za-z0-9_]。   \n\\s 　　匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  \n\\S 　   匹配一个非空白符。  \n\\t 　　 匹配一个水平制表符（tab）   \n\\r 　　 匹配一个回车符（carriage return）   \n\\n 　    匹配一个换行符（linefeed）   \n\\v 　    匹配一个垂直制表符（vertical tab）   \n\\f 　　 匹配一个换页符（form-feed）  \n\n## 2、数量词\n\nx*　　        匹配前面的模式 x 0 或多次。  \nx+ 　　      匹配前面的模式 x 1 或多次。等价于 {1,}。  \nx*? 　　     像上面的 * 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx+? 　　    像上面的 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx? 　　       匹配前面的模式 x 0 或 1 次。  \nx|y 　　      匹配 x 或 y  \nx{n}　　     n 是一个正整数。前面的模式 x 连续出现 n 次时匹配  \nx{n,} 　　   n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。  \nx{n,m}　　 n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。  \n\n## 3、字符集合\n\n[xyz] 　　  一个字符集合(字符组)。匹配集合中的任意一个字符。【你可以使用连字符\'-\'指定一个范围。[0-9] [a-z] [A-Z]】  \n[^xyz] 　　一个反义或补充字符集(反义字符组)。匹配任意不在括号内的字符。【你也可以通过使用连字符 \'-\' 指定一个范围内的字符】  \n\n## 4、边界\n\n^ 　　 匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。  \n$ 　　 匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。  \n\\b 　　匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。  \n\\B　　 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。  \n\n## 5、分组\n\n(x) 　　匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。  \n\\n 　　 n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。  \neg：\n\n```\n    /\\w+:\\/\\/\\w+(.)\\w+\\1\\w+/\n```\n\n\n拓展：  \na.在分组情况中，如果(x)后面有数量词修饰时；它也只算做一个()【括号】来算，而后面使用的\\n来指向正则表达式中该括号时，\n则是指向它重复次数的最后一次()【括号】里面所包含的内容。【可以使用str.match(正则表达式)不带g修饰符来输出进行检测查看】  \nb.\\n后面加数量词修饰则是重复\\n选择的括号里面的字串。  \neg：\n\n```\n    str = \'ababaabaa\'\n    console.log(str.match(/([a-z]).\\1/g));  //[\'aba\',\'aba\']\n    console.log(str.match(/([a-z]){2}.\\1/g));  //[\'abab\',\'aaba\']\n    console.log(str.match(/([a-z]){2}.\\1{2}/g));  //[babaa]\n    console.log(str.match(/([a-z]).\\1{2}/g));  //[\'abaa\']\n```\n', 'js正则表达式中相关字符的解释含义', 1584547200000, 875, 3, 1587642782000);
INSERT INTO `article_content` VALUES (5, 'ES6 变量与解构(二)', '## 一、变量的声明与使用 【测试示例需要在node环境中测试,浏览器环境下并不完全兼容ES6代码】\n\nES6中可以使用 {} 来包含任意一段代码,被 {} 包裹的内容称为一个代码块(局部作用域)\n\nlet关键字　【声明变量】\n特性：\n1.块级作用域    【局部作用于声明的代码块中】\n2.变量声明不会提升    【变量未声明前无法使用该变量】\n3.暂时性死区    【该变量声明前面的区域】\n4.不能重复声明    【同一代码块中不能重复声明同一变量】\n\nconst关键字    【声明常量(一般用大写字母表示常量)】\n特性：【在遵从let声明变量的特性上再添加如下两条特性】\n1、声明时初始化    【声明的同时必须赋值】\n2、值不可修改\n\n## 二、解构\n\n1、数组的解构赋值　【左边是变量,右边是值,左边无匹配值时为undefined】\n完全解构【左右数据恰好匹配】\neg：\n\n```\n    let [a,b,c] = [1,2,3];\n```\n\n\n不完全解构【左右数据不同】\na、左边数据多则只声明该变量,其值为undefined\nb、右边数据多余项则忽视不考虑\neg：\n\n```\n    let [a, [b], d] = [1, [2, 3], 4];     //a = 1; b = 2; d = 4 \n```\n\n\n集合解构【扩展运算符的使用...】\na、...tail返回目前右边未匹配的所有值组成的数组\neg：\n\n```\n    let [head, ...tail] = [1, 2, 3, 4]; //head = 1; tail = [2, 3, 4]\n    //累加操作\n    let sum = 0;\n    function test(...arr){\n        //rest参数【扩展运算符形式接受的参数,返回的为参数数组】 ------>不在推荐使用arguments参数类数组对象\n        //arr = [1,2,3,4,5]\n        for(let i=0;i<arr.length;i++){\n            sum +=arr[i];\n        }\n    }\n    \n    test(1,2,3,4,5);\n```\n\n\n默认值【当匹配值严格等于undefined,默认值生效】\neg：\n\n```\n    let [x, y = \'b\'] = [\'a\']; 　　// x=\'a\', y=\'b’\n```\n\n\n默认值为函数\n注：先判断是否匹配到值,若匹配值严格等于undefined,再进行默认值的赋值运算;否则,默认值赋值操作不会执行\neg：\n\n```\n    function test() {\n        console.log(\'test\');\n        return 2;\n    }\n    let [x = test()] = [];\n    console.log(x);        //test    2\n```\n\n\n    \n2、对象的解构赋值　【右边不存在左边变量对应的属性名时,对象属性值为undefined;即对象中未声明的属性的值为undefined】\n对象原始结构赋值【变量重命名后,最终声明的变量是重命名的变量】\neg：\n\n```\n    let {name:myName,age:myAge} = {name:\'nzc\',age:18}\n    //上面代码类比于下面代码【左边name匹配右边对象中同名属性获取其属性值并赋值给name重命名的myName变量==》将let myName = \'nzc\'】\n    let myName = \'nzc\';\n    let myAge = 18;\n```\n\n​    \n对象的属性没有次序,变量必须与属性同名才能取到正确的值【重命名相同可以简写】\neg：\n\n```\n    let {name:name,age:age} = {name:\'nzc\',age:18}\n    //简写如下\n    let {name,age} = {name:\'nzc\',age:18}\n    //类比于下面代码\n    let name = \'nzc\';\n    let age = 18;\n```\n\n\n对象嵌套解构\neg：\n\n```\n    let person = { param: [ \'nzc\', { age: 18 } ] };\n    let { param: [name, { age }] } = person; //name=\'nzc\' age=18\n    //类比于下面   param变量被重命名为 [name, { age }],所以自身并未声明;即不存在param变量\n    let { param: [name, { age }] } = { param: [ \'nzc\', { age: 18 } ] }\n```\n\n​    \n默认值(默认值生效的条件是，对象的属性值严格等于undefined)\neg：\n\n```\n    //name=\'nzchs\'->name变量默认值;age:myAge=21->myAge默认值【age重命名为myAge再赋予默认值】\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\',age:18}\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\'}  \n```\n\n\n    \n3、字符串的解构赋值\n解构时，字符串被转换成了一个类似数组的对象。\neg：\n\n```\n    let [a, b, c] = \'hello\'; //a=h;b=e;c=l\n```\n\nlength属性解构\neg：\n\n```\n    let {length : len} = \'hello\'; //len = 5 【匹配右边字符串转换为的类数组对象的length属性并将其值赋值给重命名的len变量】\n```\n\n \n\n\n4、数值和布尔值解构赋值\n解构时，如果等号右边是数值和布尔值，则会先转为相应的基本引用数据类型对象\neg：\n\n```\n    let {toString: str1} = 123; //函数 str1 === Number.prototype.toString     返回true\n    let {toString: str2} = true; //函数 str2 === Boolean.prototype.toString        返回true\n```\n\n\n\n5、函数参数的解构赋值\n基本数组解构赋值传参\neg：\n\n```\n    function add([x, y]){ return x + y; }\n    add([1, 2]);   //函数add返回值为3 \n```\n\n\n函数参数带有默认值\neg：\n\n```\n    function test({x = 0, y = 0}) {\n        return [x, y];\n    }\n    //函数调用\n    test({x: 3, y: 8}); // 返回值为[3, 8]\n    test({x: 3}); // 返回值为[3, 0]\n    test({}); // 返回值为[0, 0]\n    test(); //报错 Cannot destructure property `x` of \'undefined\' or \'null\'\n```\n\n## 三、解构常用用途\n\n1、变量值的交换\neg：\n\n```\n    let x = 1;\n    let y = 2;\n    [x,y] = [y,x];  \n    console.log(x,y); //2 1    \n```\n\n2、函数参数的赋值：\neg：\n\n```\n    //[a=0,b=1] = [1]   a=1,b=1\n    function test([a=0,b=1]){\n        return a+b;\n    }\n    test([1]);  //返回值为2\n```\n\n3、提取对象中的数据\neg：\n\n```\n    let obj= { id: 42, status: \"OK\", data: [867, 5309] };\n    let { id, status, data: number } = obj;  //定义对应的变量 \n```\n\n4、输入模块的指定方法\n\n```\n    const { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n5、遍历map结构\n\n```\n    var map = new Map();\n    map.set(\'name\', \'nzc\');\n    map.set(\'age\', 18);\n    for (let [key, value] of map) {\n        console.log(key + \" is \" + value);    // name is nzc   age is 18\n    }\n```\n\n ', 'ES6中定义变量新增关键字及解构的基本用法', 1584720000000, 3421, 2, 1585377428000);
INSERT INTO `article_content` VALUES (6, 'react安装配置', '**一、React安装配置**\r\n\r\n使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速\r\n\r\n1、全局安装最新版本的npm依赖包\r\n\r\n```\r\n$ npm install npm@latest -g\r\n```\r\n\r\n2、安装淘宝镜像【从国内存储库中下载相应的依\r\n\r\n```\r\n$ npm install -g cnpm --registry=[https://registry.npm.taobao.org\r\n```\r\n\r\n3、全局安装脚手架\r\n\r\n```\r\n$ cnpm install -g create-react-app my-app\r\n```\r\n\r\n4、进入项目目录\r\n\r\n```\r\n$ cd my-app\r\n```\r\n\r\n5、启动项目\r\n\r\n```\r\n$ yarn start  或者 cnpm start\r\n```\r\n\r\n\r\n\r\n一些需要的依赖包安装：\r\n\r\n1、安装sass包依赖\r\n\r\n```\r\n$ yarn add sass-loader node-sass --save-dev\r\n```\r\n\r\n2、代码规范配置\r\n\r\n3、安装路由依赖包\r\n\r\n```\r\n$ yarn add react-router-dom --save-dev\r\n```\r\n\r\n4、安装js对象与表单格式的转换依赖包\r\n\r\n```\r\n$ yarn add qs --save-dev\r\n```\r\n\r\n5、安装路由机制依赖包\r\n\r\n```\r\nyarn add react-router-dom --save-dev\r\n```\r\n\r\n从依赖包中导入需要使用的路由相关的变量\r\n\r\n```\r\nImport { HashRouter,NavLink,Switch,Route,Redirect } from ‘react-router-dom’;\r\n```\r\n\r\n设置导航及路由组件：\r\n\r\n```\r\n<HashRouter>\r\n\r\n​    <NavLink activeClassName=\"active\" exact to=\"/\">首页</NavLink>\r\n\r\n​    <NavLink activeClassName=\"active\" to=\"/student\">student</NavLink>\r\n\r\n\r\n\r\n​    <Switch>\r\n\r\n​        <Route exact path=\"/\" component={Index}><Route>\r\n\r\n​        <Route path=\"/student\" component={Student}><Route>\r\n\r\n​        <Route path=“/course“ render(()=>{return <div>course</div>})><Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n\r\n\r\n**二、React框架的三大特点：**\r\n\r\n**1、VRDOM【虚拟dom】**\r\n\r\na、首先构建虚拟DOM树并存储于内存中【具有单页面Web应用的一些优缺点】\r\n\r\nb、在页面数据更新时局部渲染页面【使用diff算法比较页面变化前后的两颗VRDOM树只更新渲染改变的部分（数据更新效率更快）】\r\n\r\n\r\n\r\n**2、组件化 -- JSX语法**\r\n\r\na、函数组件（无状态组件）\r\n\r\nb、class类组件（状态组件）\r\n\r\n容器：不可更改的标签元素，也不能定义为组件【容器若更改，它里面的所有后代元素也会重新渲染（需要定制shouldComponentUpdagte()钩子函数或使用hook），所以一般容器标签元素不可更改】\r\n\r\n\r\n\r\n**3、单向数据流**\r\n\r\n数据只能从父组件向子组件传递数据信息\r\n\r\n**父传子：**\r\n\r\n​    父组件将值作为子组件的属性值传递给子组件\r\n\r\n​    子组件通过this.props.attrName获取相应的值\r\n\r\n\r\n\r\n默认情况下会统一同步，父子数据不想要同步时，将传递给子组件的数据存成子组件的state【在组件挂载前保存更新state数据】\r\n\r\n\r\n\r\n**子传父：**\r\n\r\n​    子组件设置一个函数，在函数内部调用父组件的回调函数（this.props.回调函数名）\r\n\r\n​    父组件中设置一个回调函数传递给子组件并通过该函数获取相应子组件传递过来的参数值。\r\n\r\n\r\n\r\n​    ref属性：【不是特殊情况下，一般不建议使用(它是通过获取标签元素来进行的一些相关操作，与react中的VRDOM有点背道而驰)】\r\n\r\n父组件也可以通过this.refs.子组件ref属性值来获取相应的子组件并可以调用子组件中的状态值。\r\n\r\n\r\n\r\n**三、React中动态传参**\r\n\r\n参考链接：<https://www.jianshu.com/p/77467c15a0ce>\r\n\r\n**1、动态路由传参**【推荐使用】\r\n\r\n```\r\n<Link to=\"/student/sam\">学生</Link>\r\n\r\n//或者\r\n\r\nhashHistory.push(“/user/sam”)\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student/:name\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.match.params.name来获取传递过来的name参数值\r\n\r\n**注：**\r\n\r\n​    该方法可以传递一个或多个值，但值的类型都是字符串【传递一个对象时需要将js对象转换成JSON字符串传递】\r\n\r\n**2、查询字符串传参**【不推荐使用：刷新页面参数丢失】\r\n\r\n```\r\n<NavLink to=“student?name=zhangsan&age=21\"></NavLink>\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.location.name\r\n\r\n3、**API传参**【】\r\n\r\n```\r\nthis.props.history.push({\r\n\r\n​    pathname:”/student”,   //跳转的组件路径\r\n\r\n​    payload:”传递的参数\"\r\n\r\n})\r\n\r\nthis.props.location.payload     //获取传递过来的参数数值\r\n```\r\n', '使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速', 1584266350598, 6754, 1, 1587644360000);
INSERT INTO `article_content` VALUES (7, 'Redux知识整理', '## 1、创建reducer纯函数【返回最新的状态值state】\n\n创建一个或多个reducer纯函数文件\n\nreducer中设置初始state数据信息\n\n将状态数据state与分发的action对象作为reducer文件中纯函数的两个参数\n\n```\nconst initialState = [];\n\nconst reducer = (state = initialState, action) => {\n\n​    switch() {\n\n​        case ‘reset’:\n\n​            return { ...state, value: action.value };\n\n​        case ‘update’:\n\n​            return Object.assign({}, state, action.payload);\n\n​        default:\n\n​            return state;\n\n​    }\n\n}\n\nexport default reducer;\n```\n\n在获取到分发的action对象匹配对应类型执行相应的业务逻辑处理【更改state中的数据信息】\n\n\n\n## 2、整合reducer\n\n将多个reducer进行整合并可以进行重新命名\n\n```\ncombineReducers({\n\n​    test1:test1Reducer,\n\n​     test2:test2Reducer\n\n})\n```\n\n\n## 3、创建数据源store\n\n将整合的reducer作为createStore()函数的参数创建数据源信息\n\n```\nconst store = createStore(reducer);\n```\n\n**react-redux核心：**<https://www.jianshu.com/p/186956ac666a>\n\n\n\n## 4、Provider组件【容器组件：****负责管理数据和逻辑****】\n\n从react-redux中结构处Provider组件并将其作为整个项目的根元素，将store作为组件的属性向下传递\n\n结合connect函数，后代组件便可以通过props属性获取到store中的数据信息\n\n\n\n## 5、connect函数【连接React组件与Redux store】【展示(UI)组件：****负责 UI 的呈现****】\n\ncoonect函数中的第一个参数包含了原来监听者更新渲染数据的作用【使用connect函数后就不需要再对其另外添加阅读者监听事件渲染更新state】\n\n函数中有两个参数：\n\n参数一:    mapStateToProps函数【将store中的数据作为props绑定到组件上】\n\n```\nmapStateToProps = (state,ownProps)=>{\n\n​    return state;\n\n}\n```\n\n参数二:    mapDispatchTpProps函数【将 action 作为 props 绑定到组件上，也会成为 MyComp 的 props】\n\n```\nmapDispatchToProps = (dispatch,ownProps)=>{    \n\n​    return {\n\n​        changeMsg:()=>{\n\n​            dispatch({\n\n​                type:’CHANGE_MSG’,\n\n​                payload:需要更改的值\n\n​            })\n\n​        }\n\n​    }\n\n}\n```\n\n\n\n## 6、更改或获取store中的state数据\n\n在对应的reducer纯函数中通过分发的action对象执行相应的业务逻辑处理\n\na、判断actiond的type类型，通过action对象中的payload参数信息更新初始state中的数据\n\n\n\n## 7、使用中间件react-thunk或react-saga执行异步请求操作\n\n**在组件js文件中运行相应事件函数分发action**\n\n```\nconst mapDispatchToProps = (dispatch,ownProps) =>{\n\n​    return {\n\n​        getData:()=>{\n\n​            dispatch(getDataAxAction({\n\n​                pageno:1,\n\n​                pagesize:7\n\n​            }));\n\n​        }\n\n​    }\n\n}\n```\n\n**react-thunk：**\n\n在创建store文件中创建thunk中间件\n\n安装react-thunk依赖包：\n\n```\nyarn add react-thunk\n```\n\n**在创建store时编写下面代码**\n\n```\nimport { createStore,applyMiddleware,compose } from \'redux’;\n\nimport thunk from \'redux-thunk’; \n\nimport reducer from \'./reducers’; \n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?       window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; \n\nconst enhancer = composeEnhancers(applyMiddleware(thunk)) \n\nlet store = createStore(reducer,window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); let store = createStore(reducer,enhancer); \n\nexport default store;\n```\n\nreact-thunk异步请求在创建actio文件中创建执行【创建action函数并返回一个函数(可以进行异步请求操作)】\n\n// redux-thunk actionCreator【创建的action函数可以返回一个函数(即可以调用axios执行异步请求数据操作)】\n\n```\nexport const getDataAxAction = (value)=>{   \n\n​    return (dispatch)=>{     \n\n​        axios.get(\'http://134.175.154.93:8099/manager/article/findArticle’, {params:value}).then((res)=>{       \n\n​            //res.data.data.list【获取到查询结果后再次分发action，创建action并将异步请求结果赋值给action.value上】      \n\n​            dispatch(changeArticles(res.data.data.list));     \n\n​        }).catch((error)=>{       \n\n​            console.log(error);     \n\n​        });   \n\n​    }; \n\n}\n```\n\n**react-saga：**\n\n在创建store文件中创建saga中间件\n\n安装react-saga依赖包：\n\n```\n$ yarn add react-saga\n```\n\n在创建store时编写下面代码\n\n```\n// 创建store\nimport { createStore,applyMiddleware,compose } from \'redux’; \nimport reducer from \'./reducers’; \nimport createSagaMiddleware  from \'redux-saga’; \nimport mySagas from \'./mySagas’;\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst sagaMiddleware = createSagaMiddleware(); \n\nconst enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)) \n\nlet store = createStore(reducer,enhancer); \n\n//在这里使用mySagas【在store创建好后，中间件挂好后在使用mySagas】 \n\nsagaMiddleware.run(mySagas);\n\nexport default store;\n```\n\n创建mySagas文件：【组件分发相应的action，mysaga中间件文件根据actionType匹配相应的action执行异步请求后，再次分发action对象，在reducer文件中同步请求更改store中的状态数据】\n\n```\nimport { takeEvery,put } from ‘redux-saga/effects’;\n\n//创建mySagas【generator函数】函数后，在创建store仓库中使用mySagas【saga中间插件调用run方法使用】\nfunction* mySagas(){   // console.log(11111);   \n​    //监听某个action,然后执行第二个参数gengerator函数   \n​    yield takeEvery(GET_DATA_SA_ACTION,getList);   \n}\n\n//参数action就是对应的action对象 \nfunction* getList(action){   \n​    //发送异步，异步成功后分发action   \n​    let res = yield axios.get(url,   {params:action.value});   \n​    //put就是转发action，类似于dispatch，然后执行同步请求执行相应的业务逻辑处理   \n​    yield put(changeArticles(res.data.list)); \n}\n```\n\n', '前端状态数据管理库redux结合react-thunk或react-saga中间件的基本使用', 1584266350598, 1098, 1, 1584266350598);
INSERT INTO `article_content` VALUES (8, 'VSCode常用插件和技巧教程（1）', '  VSCode 想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。  \n## P01：VSCode实现毛玻璃效果\n\n技术胖虽然长的难看，但绝对是喜欢漂亮人和物的，比如说小姐姐。那作为一个前端程序员，肯定也会让自己的VSCode越漂亮越好。这个文章我就介绍一下，如何让VSCode拥有漂亮的毛玻璃效果。\n\n毛玻璃的朦胧美，就仿佛美女穿了黑色的丝袜，非常的诱人心智。\n\nVibrancy\n安装并运行插件\n\n其实要实现这个效果，只需要下载一个插件就可以解决，这个插件就是 Vibrancy。\n\n打开VSCode，然后点击插件栏，搜索插件Vibrancy，搜索到之后，点击install进行安装。\n\nVibrancy\n\n安装好主体后，你需要按F1键,打开命令输入框，然后输入Reload Vibrancy后回车。如果不起作用，你就重新启动一下VSCode.\n\n需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。\n插件设置\n\n这个插件还支持透明度和两款主题样式的设置。设置方法是在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions ，然后再找到Vibrancy Effect进行设置。\n\n一共有三项设置：\n\n    Opacity：透明度设置，这个数值默认为-1，你可以输入自己喜欢的值0-1之间，比如0.8.\n    Theme： 毛玻璃的样式设置，一共有三个样式可选，以后可能还会增加。\n    Type： 这个有很多选项，你可以具体进行测试。\n\n## P02：VSCode里直接预览效果\n\n如果你没有双屏显示器，又不想来回切换窗口，而是直接在VSCode里进行预览，这简直太方便了，剩下的时间看个岛国小电影或者玩两把守望屁股他不香吗?\n\n来来来，快点开始吧，妹子和游戏都在向我招手。\n\nBrowser Preview\n安装Browser Preview\n\n打开插件管理，然后搜索Browser Preview插件，直接进行安装。\n\nBrowser Preview\n\n安装完成后，在Bar上多出一个图标，点击图标就可以在VSCode里打开浏览器了。\n修改默认打开网址\n\n现在的默认地址确实烦人，每次都要重新输入，这是一个有贞操的程序员所不能忍受的。所以我们按住ctrl + ,打开设置，然后找到Extensions,再找到Browser Preview,找到Start Url写上你默认打开的地址就可以了。\n## P03：VSCode一个插件让你的代码更职业\n\n你有没有怀疑过你写的JavaScript代码？如何让自己的代码更专业？VSCode中的JavaScript Booster可以快速提升你的代码专业度。\n\n插件安装完成，不用配置任何东西，就可以使用了。\n\nJavaScript Booster\n插件的基本使用\n\n插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码。\n\n比如我们新建一个js文件，写如下代码：\n\nvar string1= \'jspang.com\';\n\n这时候我们点击var 关键词，JavaScript Booster就会给我们出现黄色小灯泡，我们点击黄色小灯泡后，它会提示我们var可以换成const.直接点击更换。\n\n更换后的代码变成了这个样子。\n\nconst string1= \'jspang.com\';\n\n再比如你写了这样一段代码：\n\nconst gogo = function(str){\n    return \'hi\'+ str\n}\n\n这时候你点击function后，它会出现黄色警告，点击后会提示改为箭头函数，再次点击hi，又会出现警告，说可以使用模板字符串。两次点击后就代码就变成了下面的样子。\n\nconst gogo = str => {\n    return `hi${str}`;\n}\n\n再比如，你要去象牙山洗脚城去大宝剑一下的时候，如果你选择32号就是“刘英”为你服务，如果你选择其它的就是“谢大脚”为你服务。\n\nlet a = 32\nlet str1=\'jspang\'\nif(a===32){\n    str1=\'刘英\'\n}else{\n    str1=\'谢大脚\'\n}\n\n这时候你点击if会提示你改为三元运算符的形式，就变成了这样。\n\nlet a = 32\nlet str1=\'jspang\'\nstr1 = a===32 ? \'刘英\' : \'谢大脚\';\n\n这个插件还有很多转换方式，你可以在写完代码后都点击点击，这样慢慢的你代码水平就会提高。\n## P04：VSCode界面透明插件 程序员上班看片神器\n上次介绍了一个毛玻璃插件，小伙伴都说不太好用，那我这个文章就介绍我的一个我的御用插件`Windows opacity`。有了这个插件，从此上班偷偷看看小姐姐，偷偷看视频时完全可以的。\n\nWindows opacity\n安装并运行插件\n\n安装这个插件是非常简单的，只要打开VSCode,然后点击插件Icon图标，进入插件，在搜索栏上搜索windos opacity,然后找到如图插件，进行安装就可以了。\n\nWindows opacity\n\n安装好后，需要重启一下VSCode，就可以出现透明效果了。\n插件的设置\n\n现在的透明度可能看片还是有一点问题的，那我们就把透明度调的高一点。在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions选项卡，然后找到Windows opacity进行设置。\n\n这里边只有一个设置项，就是Opacity，也就是我们要设置的透明度，值从0-255,数值越小透明度越高，数值越大透明度越低。我一般摸鱼的透明度在230左右，再小就容易被发现了。', '想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。', 1584266350598, 3526, 4, 1587644746000);
INSERT INTO `article_content` VALUES (9, 'Navicat连接腾讯云服务器上的数据库（1）', '## 下面介绍Navicat连接腾讯云服务器上的数据库的两种方法：\n\n## 方法一：【不需要修改相关远程客户端连接权限】\n\n点击安装好的桌面navicat图标，进入后如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214202494-819455691.png)\n\n连接方法：ssh中输入自己服务器的外网ip地址，登录服务器账号和密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214402984-1454339889.png)\n\n \n\n再设置常规属性中，数据库的连接，主机填localhost，因为mysql安装在了本地服务器上，然后填入mysql的用户名及密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214519764-88496090.png)\n\n \n\n \n\n## 方法二：【修改相关MySQL远程客户端连接权限】\n\n下面命令最好在root用户下执行使用：【否则可能会一些文件修改权限受阻问题，需要手动修改用户对文件的使用权限】\n\n#### 1、我们需要更改 3306端口，查看3306 端口是否对外开放，而一般MySQL 默认情况下是不开放对外访问功能的。\n\n使用下面语句进行查询：\n\n \n\n```\n# netstat -an | grep 3306\n```\n\n如果查询结果如下，则需要我们更改 MySQL 配置文件。\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214621204-572794575.png)\n\n查询结果可以看出，MySQL的3306端口只是监听本地的连接，这样就阻碍了外部IP对该数据库的访问，修改 MySQL 配置文件：\n\n```\n# /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在MySQL配置文件中找到  bind-address = 127.0.0.1 这一行\n\n将bind-address = 127.0.0.1 这行注释掉或者改为你想要使用的客户端主机 ip。如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214704648-229822164.png)\n\n \n\n \n\n这样，我们的 MySQL 远程访问端口就开启成功了。\n\n \n\n#### 2、我们进入 MySQL 命令界面，运行下列SQL 语句：\n\n \n\n使用下面命令先在服务器终端上登录mysql的root用户\n\n \n\n```\n# mysql -uroot -p\n```\n\n \n\n然后输入root用户密码就可以登录mysql了\n\n \n\n使用下面命令切换为使用mysql数据库\n\n \n\n```\nmysql> use mysql; \n```\n\n \n\n使用下面命令查看用户是否具有访问权限：\n\n \n\n```\nmysql> select user, host from user;\n```\n\n \n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214823443-1521450522.png)\n\n \n\n上面显示root用户只用访问本地的权限，我们需要通配符 % 来修改 root 用户对应的 host 字段，使其具有访问所有 ip 地址的权限：\n\n```\nmysql> update user set host = \'%\' where user = \'root\';\n```\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214943424-1543189887.png)\n\n \n\n如果抛出如下异常：\n\n```\nDuplicate entry \'%-root\' for key \'PRIMARY\'\n```\n\n说明有多个root用户纪录在user表中了，我们重新执行下面命令就可以看到字段 host 的 % 值：\n\n```\nmysql> select host from user where user = \'root\';\n```\n\n我们执行：\n\n```\nmysql> flush privileges;\n```\n\n刷新一下 MySQL 的系统权限相关表。\n\n下面还要确认的一件事就是确认客户端用户是否具有权限，我们给与他们相应的访问权限：\n\n```\nmysql> grant all privileges on *.* to username@\"%\" identified by \"password\";\n```\n\n最后退出mysql重启一下 MySQL 服务：\n\n```\nmysql> exit;   //退出mysql\n#sudo mysql restart   //重启mysql服务\n```\n\n#### 3、服务端设置好了，我们在 Navicat 客户端设置一下连接：\n\n打开 Navicat软件，点击左上方的 \"连接\"，设置一下数据库的连接名，服务器外网ip地址，mysql用户名及密码等，\n\n点击测试连接成功后再点击确定按钮便能在 Navicat 中远程操作服务器上的 MySQL 了。\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705215031893-1645905718.png)\n\n \n\n \n\n到这里，Navicat连接腾讯云服务器上的数据库的两种方法就结束了，希望可以帮助大家。。。', '介绍Navicat连接腾讯云服务器上的数据库的两种方法', 1586268227000, 1078, 4, 1586268733000);
INSERT INTO `article_content` VALUES (10, 'js数组【续】(相关方法)（1）', '## 一、数组的栈，队列方法【调用这些方法原数组会发生改变】\n\n```\n    var arr = [2,3,4,5,6];\n```\n\n1.栈 LIFO (Last-In-First-Out)\n\n a、push() 可接受任意类型的参数，将它们逐个添加到数组的末尾。【返回数组的长度】\n\n```\n    console.log(arr);  //[2,3,4,5,6]\n    console.log(+arr.push(7)); //返回添加数据后数组的长度：6\n    console.log(arr);  //[2,3,4,5,6,7]\n```\n\nb、pop() 从数组的末尾移除最后一项，减少数组的length值。【返回移除的项】\n\n```\n    console.log(arr.pop()); //取出栈顶元素并返回该栈顶元素值：7\n    console.log(arr);  //[2,3,4,5,6]\n```\n\n2.队列 FIFO (First-In-First-Out)\n\na、shift() 移除数组中的第一个项，同时将数组的长度减一。【返回移除的项】\n\n```\n    console.log(arr.shift()); //hello\n    console.log(arr); //[2,3,4,5,6]\n```\n\nb、unshift() 在数组的前端添加任意个项。【返回数组的长度】\n\n```\n    console.log(arr.unshift(\'hello\')); //6\n    console.log(arr); //[\'hello\',2,3,4,5,6]\n```\n\n## 二、数组的排序方法【reverse()方法、sort()方法】(原数组发生改变)\n\nvar arr = [23,56,12,43,6,23,26];\n\n1、reverse()方法：【对数组项进行反转】\n\n```\n    console.log(arr);\n    //反转 翻转 reverse  改变原数组\n    console.log(arr.reverse());\n    console.log(arr);\n```\n\n2、sort()方法【数组排序,返回排序后的数组】\n\na、sort()不带参数默认为升序\n\n```\n    console.log(arr.sort()); //按照字符串ASSIC码形式比较\n```\n\nb、sort()带指定排序函数\n函数返回值：\n    正值：交换\n    负值：不交换\n\n```\n    console.log(arr.sort(com));\n    console.log(arr);\n    function com(a,b){\n        //return a-b;  //升序\n        //负数a,b不发生交换 a b  a<b 负值  不交换;  a b  a<b  升序排列\n        //正数数a,b不发生交换   a b  a>b 正值  交换;   b  a   b<a  升序排列\n\n        //return b-a;  //降序\n\n        //升序\n        if(a<=b){\n                return -1;  //负数不发生交换\n        }else{\n                return 1;  //正数发生交换\n        }\n```\n\n3、查找最高(最低)的数组值\n\na.使用sort()方法先进行排序，然后再在排好序的数组中取值\nb.使用Math.max.apply()和Math.min.apply()方法\n\n```\n    Math.max.apply(null,array);　　//获取array数组中的最大值\n    Math.min.apply(null,array);　　//获取array数组中的最小值\n```\n\n## 三、截取方法：\n\n1、数组拼接：concat()方法 【不改变原数组】\n\n先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，返回副本数组。\neg:\n\n```\n    var arr = [3,4,5,2,4];\n    var arr2 = [1,2,3,4,5];\n\n    var result = arr.concat(arr2);\n    console.log(arr);    //[3,4,5,2,4]\n    console.log(result);    //[3,4,5,2,4,1,2,3,4,5]\n\n    var result2 = arr.concat(\'hello\');\n    console.log(result2);    //[3,4,5,2,4,\'hello\']\n```\n\n2、数组切割：slice()方法 【不改变原数组】\n\nslice(返回项的起始位置，结束位置);\n一个参数：从该参数指定的位置开始，到当前数组末尾的所有项。\n两个参数：起始到结束之间的项，但是不包含结束位置的项。\neg:\n\n```\n    //参数是一个为从开始位置截取到末尾；参数是两个的，截取部分为开始位置到结束位置不包括结束位置的值\n    //返回截取部分的值,不改变原数组\n    var arr = [123,34,5,67,3,6,8];\n    var result = arr.slice(2);\n    console.log(result);  //[5,67,3,6,8]\n    console.log(arr);  //[123,34,5,67,3,6,8]\n\n    var result2 = arr.slice(2,4);\n    console.log(result2); //[5,67]\n```\n\n3、splice() 【改变原数组】\n\n向数组的中部插入数据将始终返回一个数组，该数组中包含从原始数组中删除的项。\n删除：指定一个参数(删除的开始的位置)【删除该参数索引及后面的所有元素】；指定两个参数(删除的起始位置，要删除的项数) 【返回删除的元素组成的数组】\n插入：指定三个参数(起始位置，0，要插入的项任意数量的项) \n替换：指定三个参数(起始位置，要删除的项数，要插入的任意数量的项)\neg:\n\n```\n    //删除\n    var arr = [32,4,9,3,0];\n    var result = arr.splice(1,3);\n    console.log(result);  //[4,9,3]\n    console.log(arr); //[32,0]\n\n    //插入\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,0,\'hello\',\'sss\');\n    console.log(arr);  //[32,\'hello\',\'sss\',4,9,3,0]\n\n    //替换\n    //从索引位置为1的删除两项后在开始位置处再插入一些元素\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,2,1,2);\n    console.log(arr); //[32,1,2,3,0]\n```\n\n## 四、索引方法\n\nindexOf lastindexOf 返回索引或-1\nvar arr = [2,5,67,\'2\',3,2,45];\n\n1、indexOf() \n\n从数组开头向后查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    //参数：要查找的元素   开始查找的位置\n    console.log(arr.indexOf(2)); //0\n    console.log(arr.indexOf(2,1)); //5\n    console.log(arr.indexOf(22)); //-1\n```\n\n2、lastIndexOf() \n\n从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    console.log(arr.lastIndexOf(2));  //5\n    console.log(arr.lastIndexOf(2,3)); //0\n```\n\n3.常用于判断数组中是否含有该元素\n\n```\n    if(arr.indexOf(2) != -1){ }\n```\n\n## 五、迭代方法\n\n参数： 每一项上运行的函数，运行该函数的作用域对象（可选）\n\n1、every() \n\n对数组中的每一运行给定的函数参数，如果该参数函数对每一项都返回true,则该函数返回true\neg:\n\n```\n    var arr = [23,45,1,4,3,45,7];\n    var result = arr.every(function(item,index,arr){\n        console.log(this); //{}\n        return item>20;\n    },{});\n    console.log(result); //false\n```\n\n2、some(),3、filter(),4、map()使用的数组如下：\n\n```\nvar stus = [\n        {\n                name:\'zhangsan\',\n                age:20\n        },{\n                name:\'lisi\',\n                age:13\n        },{\n                name:\'wangwu\',\n                age:12\n        }\n];\n```\n\n2、some() \n\n对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true\neg：\n\n```\n    //判断是否有未成年人，有返回true，否则返回：false\n    var result = stus.some(function(item,index,arr){\n         return item.age<18\n    });\n    console.log(result); //true\n```\n\n3、filter() \n\n对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组\neg：\n\n```\n    //filter\n    //过滤出来所有成年人\n    var result = stus.filter(function(item,index,arr){\n        return item.age>18;\n    });\n    console.log(result);\n\n    //查找所有未成年人的名字\n    //先过滤出所有未成年人再映射出符合条件人名字\n    var result = stus.filter(function(item,index,arr){\n        return item.age<18;\n    }).map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n```\n\n4、map()\n\n对数组中的每一元素运行给定的函数,返回每次函数调用的结果组成的数组\n\n```\n    //map\n    //查找处所有人的名字,返回数组\n    var result = stus.map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n    var result = stus.map(function(item,index,arr){\n        return item.age*2;\n    });\n    console.log(result);\n```\n\n5、forEach() \n\n对数组中的每一元素运行给定的函数,没有返回值，常用来遍历元素\n\n```\n    //数组的遍历\n    var arr = [{\n        name:\'zhangsan\'\n    },{\n        name:\'lisi\'\n    },{\n        name:\'terry\'\n    }];\n    //向数组各元素对象中添加age属性\n    var ageInit = 10;\n    arr.forEach(function(item,index,arr){\n        item.age = ageInit++;\n    });\n    console.log(arr);\n```\n\n ', 'js数组中一些常用的方法基本使用', 1584547200000, 1276, 3, 1585017659000);
INSERT INTO `article_content` VALUES (11, 'js正则表达式【续】(相关字符的解释含义)（1）', '## 1、字符类\n\n[直接量] \n. (点号，小数点) 匹配任意单个字符，但是行结束符除外  \n\\d 　　匹配一个0-9之间的阿拉伯数字。等价于[0-9]  \n\\D 　   匹配任意一个不是0-9之间阿拉伯数字的字  符。等价于[^0-9]。   \n\\w 　   匹配任意一个字母、数字或下划线的字符。等价于 [A-Za-z0-9_]。   \n\\W　   匹配任意一个不是字母、数字或下划线的字符。等价于 [^A-Za-z0-9_]。   \n\\s 　　匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  \n\\S 　   匹配一个非空白符。  \n\\t 　　 匹配一个水平制表符（tab）   \n\\r 　　 匹配一个回车符（carriage return）   \n\\n 　    匹配一个换行符（linefeed）   \n\\v 　    匹配一个垂直制表符（vertical tab）   \n\\f 　　 匹配一个换页符（form-feed）  \n\n## 2、数量词\n\nx*　　        匹配前面的模式 x 0 或多次。  \nx+ 　　      匹配前面的模式 x 1 或多次。等价于 {1,}。  \nx*? 　　     像上面的 * 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx+? 　　    像上面的 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx? 　　       匹配前面的模式 x 0 或 1 次。  \nx|y 　　      匹配 x 或 y  \nx{n}　　     n 是一个正整数。前面的模式 x 连续出现 n 次时匹配  \nx{n,} 　　   n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。  \nx{n,m}　　 n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。  \n\n## 3、字符集合\n\n[xyz] 　　  一个字符集合(字符组)。匹配集合中的任意一个字符。【你可以使用连字符\'-\'指定一个范围。[0-9] [a-z] [A-Z]】  \n[^xyz] 　　一个反义或补充字符集(反义字符组)。匹配任意不在括号内的字符。【你也可以通过使用连字符 \'-\' 指定一个范围内的字符】  \n\n## 4、边界\n\n^ 　　 匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。  \n$ 　　 匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。  \n\\b 　　匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。  \n\\B　　 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。  \n\n## 5、分组\n\n(x) 　　匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。  \n\\n 　　 n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。  \neg：\n\n```\n    /\\w+:\\/\\/\\w+(.)\\w+\\1\\w+/\n```\n\n\n拓展：  \na.在分组情况中，如果(x)后面有数量词修饰时；它也只算做一个()【括号】来算，而后面使用的\\n来指向正则表达式中该括号时，\n则是指向它重复次数的最后一次()【括号】里面所包含的内容。【可以使用str.match(正则表达式)不带g修饰符来输出进行检测查看】  \nb.\\n后面加数量词修饰则是重复\\n选择的括号里面的字串。  \neg：\n\n```\n    str = \'ababaabaa\'\n    console.log(str.match(/([a-z]).\\1/g));  //[\'aba\',\'aba\']\n    console.log(str.match(/([a-z]){2}.\\1/g));  //[\'abab\',\'aaba\']\n    console.log(str.match(/([a-z]){2}.\\1{2}/g));  //[babaa]\n    console.log(str.match(/([a-z]).\\1{2}/g));  //[\'abaa\']\n```\n', 'js正则表达式中相关字符的解释含义', 1584547200000, 8633, 3, 1587642782000);
INSERT INTO `article_content` VALUES (12, 'ES6 变量与解构(二)（1）', '## 一、变量的声明与使用 【测试示例需要在node环境中测试,浏览器环境下并不完全兼容ES6代码】\n\nES6中可以使用 {} 来包含任意一段代码,被 {} 包裹的内容称为一个代码块(局部作用域)\n\nlet关键字　【声明变量】\n特性：\n1.块级作用域    【局部作用于声明的代码块中】\n2.变量声明不会提升    【变量未声明前无法使用该变量】\n3.暂时性死区    【该变量声明前面的区域】\n4.不能重复声明    【同一代码块中不能重复声明同一变量】\n\nconst关键字    【声明常量(一般用大写字母表示常量)】\n特性：【在遵从let声明变量的特性上再添加如下两条特性】\n1、声明时初始化    【声明的同时必须赋值】\n2、值不可修改\n\n## 二、解构\n\n1、数组的解构赋值　【左边是变量,右边是值,左边无匹配值时为undefined】\n完全解构【左右数据恰好匹配】\neg：\n\n```\n    let [a,b,c] = [1,2,3];\n```\n\n\n不完全解构【左右数据不同】\na、左边数据多则只声明该变量,其值为undefined\nb、右边数据多余项则忽视不考虑\neg：\n\n```\n    let [a, [b], d] = [1, [2, 3], 4];     //a = 1; b = 2; d = 4 \n```\n\n\n集合解构【扩展运算符的使用...】\na、...tail返回目前右边未匹配的所有值组成的数组\neg：\n\n```\n    let [head, ...tail] = [1, 2, 3, 4]; //head = 1; tail = [2, 3, 4]\n    //累加操作\n    let sum = 0;\n    function test(...arr){\n        //rest参数【扩展运算符形式接受的参数,返回的为参数数组】 ------>不在推荐使用arguments参数类数组对象\n        //arr = [1,2,3,4,5]\n        for(let i=0;i<arr.length;i++){\n            sum +=arr[i];\n        }\n    }\n    \n    test(1,2,3,4,5);\n```\n\n\n默认值【当匹配值严格等于undefined,默认值生效】\neg：\n\n```\n    let [x, y = \'b\'] = [\'a\']; 　　// x=\'a\', y=\'b’\n```\n\n\n默认值为函数\n注：先判断是否匹配到值,若匹配值严格等于undefined,再进行默认值的赋值运算;否则,默认值赋值操作不会执行\neg：\n\n```\n    function test() {\n        console.log(\'test\');\n        return 2;\n    }\n    let [x = test()] = [];\n    console.log(x);        //test    2\n```\n\n\n    \n2、对象的解构赋值　【右边不存在左边变量对应的属性名时,对象属性值为undefined;即对象中未声明的属性的值为undefined】\n对象原始结构赋值【变量重命名后,最终声明的变量是重命名的变量】\neg：\n\n```\n    let {name:myName,age:myAge} = {name:\'nzc\',age:18}\n    //上面代码类比于下面代码【左边name匹配右边对象中同名属性获取其属性值并赋值给name重命名的myName变量==》将let myName = \'nzc\'】\n    let myName = \'nzc\';\n    let myAge = 18;\n```\n\n​    \n对象的属性没有次序,变量必须与属性同名才能取到正确的值【重命名相同可以简写】\neg：\n\n```\n    let {name:name,age:age} = {name:\'nzc\',age:18}\n    //简写如下\n    let {name,age} = {name:\'nzc\',age:18}\n    //类比于下面代码\n    let name = \'nzc\';\n    let age = 18;\n```\n\n\n对象嵌套解构\neg：\n\n```\n    let person = { param: [ \'nzc\', { age: 18 } ] };\n    let { param: [name, { age }] } = person; //name=\'nzc\' age=18\n    //类比于下面   param变量被重命名为 [name, { age }],所以自身并未声明;即不存在param变量\n    let { param: [name, { age }] } = { param: [ \'nzc\', { age: 18 } ] }\n```\n\n​    \n默认值(默认值生效的条件是，对象的属性值严格等于undefined)\neg：\n\n```\n    //name=\'nzchs\'->name变量默认值;age:myAge=21->myAge默认值【age重命名为myAge再赋予默认值】\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\',age:18}\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\'}  \n```\n\n\n    \n3、字符串的解构赋值\n解构时，字符串被转换成了一个类似数组的对象。\neg：\n\n```\n    let [a, b, c] = \'hello\'; //a=h;b=e;c=l\n```\n\nlength属性解构\neg：\n\n```\n    let {length : len} = \'hello\'; //len = 5 【匹配右边字符串转换为的类数组对象的length属性并将其值赋值给重命名的len变量】\n```\n\n \n\n\n4、数值和布尔值解构赋值\n解构时，如果等号右边是数值和布尔值，则会先转为相应的基本引用数据类型对象\neg：\n\n```\n    let {toString: str1} = 123; //函数 str1 === Number.prototype.toString     返回true\n    let {toString: str2} = true; //函数 str2 === Boolean.prototype.toString        返回true\n```\n\n\n\n5、函数参数的解构赋值\n基本数组解构赋值传参\neg：\n\n```\n    function add([x, y]){ return x + y; }\n    add([1, 2]);   //函数add返回值为3 \n```\n\n\n函数参数带有默认值\neg：\n\n```\n    function test({x = 0, y = 0}) {\n        return [x, y];\n    }\n    //函数调用\n    test({x: 3, y: 8}); // 返回值为[3, 8]\n    test({x: 3}); // 返回值为[3, 0]\n    test({}); // 返回值为[0, 0]\n    test(); //报错 Cannot destructure property `x` of \'undefined\' or \'null\'\n```\n\n## 三、解构常用用途\n\n1、变量值的交换\neg：\n\n```\n    let x = 1;\n    let y = 2;\n    [x,y] = [y,x];  \n    console.log(x,y); //2 1    \n```\n\n2、函数参数的赋值：\neg：\n\n```\n    //[a=0,b=1] = [1]   a=1,b=1\n    function test([a=0,b=1]){\n        return a+b;\n    }\n    test([1]);  //返回值为2\n```\n\n3、提取对象中的数据\neg：\n\n```\n    let obj= { id: 42, status: \"OK\", data: [867, 5309] };\n    let { id, status, data: number } = obj;  //定义对应的变量 \n```\n\n4、输入模块的指定方法\n\n```\n    const { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n5、遍历map结构\n\n```\n    var map = new Map();\n    map.set(\'name\', \'nzc\');\n    map.set(\'age\', 18);\n    for (let [key, value] of map) {\n        console.log(key + \" is \" + value);    // name is nzc   age is 18\n    }\n```\n\n ', 'ES6中定义变量新增关键字及解构的基本用法', 1584720000000, 278, 2, 1585377428000);
INSERT INTO `article_content` VALUES (13, 'react安装配置（1）', '**一、React安装配置**\r\n\r\n使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速\r\n\r\n1、全局安装最新版本的npm依赖包\r\n\r\n```\r\n$ npm install npm@latest -g\r\n```\r\n\r\n2、安装淘宝镜像【从国内存储库中下载相应的依\r\n\r\n```\r\n$ npm install -g cnpm --registry=[https://registry.npm.taobao.org\r\n```\r\n\r\n3、全局安装脚手架\r\n\r\n```\r\n$ cnpm install -g create-react-app my-app\r\n```\r\n\r\n4、进入项目目录\r\n\r\n```\r\n$ cd my-app\r\n```\r\n\r\n5、启动项目\r\n\r\n```\r\n$ yarn start  或者 cnpm start\r\n```\r\n\r\n\r\n\r\n一些需要的依赖包安装：\r\n\r\n1、安装sass包依赖\r\n\r\n```\r\n$ yarn add sass-loader node-sass --save-dev\r\n```\r\n\r\n2、代码规范配置\r\n\r\n3、安装路由依赖包\r\n\r\n```\r\n$ yarn add react-router-dom --save-dev\r\n```\r\n\r\n4、安装js对象与表单格式的转换依赖包\r\n\r\n```\r\n$ yarn add qs --save-dev\r\n```\r\n\r\n5、安装路由机制依赖包\r\n\r\n```\r\nyarn add react-router-dom --save-dev\r\n```\r\n\r\n从依赖包中导入需要使用的路由相关的变量\r\n\r\n```\r\nImport { HashRouter,NavLink,Switch,Route,Redirect } from ‘react-router-dom’;\r\n```\r\n\r\n设置导航及路由组件：\r\n\r\n```\r\n<HashRouter>\r\n\r\n​    <NavLink activeClassName=\"active\" exact to=\"/\">首页</NavLink>\r\n\r\n​    <NavLink activeClassName=\"active\" to=\"/student\">student</NavLink>\r\n\r\n\r\n\r\n​    <Switch>\r\n\r\n​        <Route exact path=\"/\" component={Index}><Route>\r\n\r\n​        <Route path=\"/student\" component={Student}><Route>\r\n\r\n​        <Route path=“/course“ render(()=>{return <div>course</div>})><Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n\r\n\r\n**二、React框架的三大特点：**\r\n\r\n**1、VRDOM【虚拟dom】**\r\n\r\na、首先构建虚拟DOM树并存储于内存中【具有单页面Web应用的一些优缺点】\r\n\r\nb、在页面数据更新时局部渲染页面【使用diff算法比较页面变化前后的两颗VRDOM树只更新渲染改变的部分（数据更新效率更快）】\r\n\r\n\r\n\r\n**2、组件化 -- JSX语法**\r\n\r\na、函数组件（无状态组件）\r\n\r\nb、class类组件（状态组件）\r\n\r\n容器：不可更改的标签元素，也不能定义为组件【容器若更改，它里面的所有后代元素也会重新渲染（需要定制shouldComponentUpdagte()钩子函数或使用hook），所以一般容器标签元素不可更改】\r\n\r\n\r\n\r\n**3、单向数据流**\r\n\r\n数据只能从父组件向子组件传递数据信息\r\n\r\n**父传子：**\r\n\r\n​    父组件将值作为子组件的属性值传递给子组件\r\n\r\n​    子组件通过this.props.attrName获取相应的值\r\n\r\n\r\n\r\n默认情况下会统一同步，父子数据不想要同步时，将传递给子组件的数据存成子组件的state【在组件挂载前保存更新state数据】\r\n\r\n\r\n\r\n**子传父：**\r\n\r\n​    子组件设置一个函数，在函数内部调用父组件的回调函数（this.props.回调函数名）\r\n\r\n​    父组件中设置一个回调函数传递给子组件并通过该函数获取相应子组件传递过来的参数值。\r\n\r\n\r\n\r\n​    ref属性：【不是特殊情况下，一般不建议使用(它是通过获取标签元素来进行的一些相关操作，与react中的VRDOM有点背道而驰)】\r\n\r\n父组件也可以通过this.refs.子组件ref属性值来获取相应的子组件并可以调用子组件中的状态值。\r\n\r\n\r\n\r\n**三、React中动态传参**\r\n\r\n参考链接：<https://www.jianshu.com/p/77467c15a0ce>\r\n\r\n**1、动态路由传参**【推荐使用】\r\n\r\n```\r\n<Link to=\"/student/sam\">学生</Link>\r\n\r\n//或者\r\n\r\nhashHistory.push(“/user/sam”)\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student/:name\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.match.params.name来获取传递过来的name参数值\r\n\r\n**注：**\r\n\r\n​    该方法可以传递一个或多个值，但值的类型都是字符串【传递一个对象时需要将js对象转换成JSON字符串传递】\r\n\r\n**2、查询字符串传参**【不推荐使用：刷新页面参数丢失】\r\n\r\n```\r\n<NavLink to=“student?name=zhangsan&age=21\"></NavLink>\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.location.name\r\n\r\n3、**API传参**【】\r\n\r\n```\r\nthis.props.history.push({\r\n\r\n​    pathname:”/student”,   //跳转的组件路径\r\n\r\n​    payload:”传递的参数\"\r\n\r\n})\r\n\r\nthis.props.location.payload     //获取传递过来的参数数值\r\n```\r\n', '使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速', 1584266350598, 1100, 1, 1587644360000);
INSERT INTO `article_content` VALUES (14, 'Redux知识整理（1）', '## 1、创建reducer纯函数【返回最新的状态值state】\n\n创建一个或多个reducer纯函数文件\n\nreducer中设置初始state数据信息\n\n将状态数据state与分发的action对象作为reducer文件中纯函数的两个参数\n\n```\nconst initialState = [];\n\nconst reducer = (state = initialState, action) => {\n\n​    switch() {\n\n​        case ‘reset’:\n\n​            return { ...state, value: action.value };\n\n​        case ‘update’:\n\n​            return Object.assign({}, state, action.payload);\n\n​        default:\n\n​            return state;\n\n​    }\n\n}\n\nexport default reducer;\n```\n\n在获取到分发的action对象匹配对应类型执行相应的业务逻辑处理【更改state中的数据信息】\n\n\n\n## 2、整合reducer\n\n将多个reducer进行整合并可以进行重新命名\n\n```\ncombineReducers({\n\n​    test1:test1Reducer,\n\n​     test2:test2Reducer\n\n})\n```\n\n\n## 3、创建数据源store\n\n将整合的reducer作为createStore()函数的参数创建数据源信息\n\n```\nconst store = createStore(reducer);\n```\n\n**react-redux核心：**<https://www.jianshu.com/p/186956ac666a>\n\n\n\n## 4、Provider组件【容器组件：****负责管理数据和逻辑****】\n\n从react-redux中结构处Provider组件并将其作为整个项目的根元素，将store作为组件的属性向下传递\n\n结合connect函数，后代组件便可以通过props属性获取到store中的数据信息\n\n\n\n## 5、connect函数【连接React组件与Redux store】【展示(UI)组件：****负责 UI 的呈现****】\n\ncoonect函数中的第一个参数包含了原来监听者更新渲染数据的作用【使用connect函数后就不需要再对其另外添加阅读者监听事件渲染更新state】\n\n函数中有两个参数：\n\n参数一:    mapStateToProps函数【将store中的数据作为props绑定到组件上】\n\n```\nmapStateToProps = (state,ownProps)=>{\n\n​    return state;\n\n}\n```\n\n参数二:    mapDispatchTpProps函数【将 action 作为 props 绑定到组件上，也会成为 MyComp 的 props】\n\n```\nmapDispatchToProps = (dispatch,ownProps)=>{    \n\n​    return {\n\n​        changeMsg:()=>{\n\n​            dispatch({\n\n​                type:’CHANGE_MSG’,\n\n​                payload:需要更改的值\n\n​            })\n\n​        }\n\n​    }\n\n}\n```\n\n\n\n## 6、更改或获取store中的state数据\n\n在对应的reducer纯函数中通过分发的action对象执行相应的业务逻辑处理\n\na、判断actiond的type类型，通过action对象中的payload参数信息更新初始state中的数据\n\n\n\n## 7、使用中间件react-thunk或react-saga执行异步请求操作\n\n**在组件js文件中运行相应事件函数分发action**\n\n```\nconst mapDispatchToProps = (dispatch,ownProps) =>{\n\n​    return {\n\n​        getData:()=>{\n\n​            dispatch(getDataAxAction({\n\n​                pageno:1,\n\n​                pagesize:7\n\n​            }));\n\n​        }\n\n​    }\n\n}\n```\n\n**react-thunk：**\n\n在创建store文件中创建thunk中间件\n\n安装react-thunk依赖包：\n\n```\nyarn add react-thunk\n```\n\n**在创建store时编写下面代码**\n\n```\nimport { createStore,applyMiddleware,compose } from \'redux’;\n\nimport thunk from \'redux-thunk’; \n\nimport reducer from \'./reducers’; \n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?       window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; \n\nconst enhancer = composeEnhancers(applyMiddleware(thunk)) \n\nlet store = createStore(reducer,window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); let store = createStore(reducer,enhancer); \n\nexport default store;\n```\n\nreact-thunk异步请求在创建actio文件中创建执行【创建action函数并返回一个函数(可以进行异步请求操作)】\n\n// redux-thunk actionCreator【创建的action函数可以返回一个函数(即可以调用axios执行异步请求数据操作)】\n\n```\nexport const getDataAxAction = (value)=>{   \n\n​    return (dispatch)=>{     \n\n​        axios.get(\'http://134.175.154.93:8099/manager/article/findArticle’, {params:value}).then((res)=>{       \n\n​            //res.data.data.list【获取到查询结果后再次分发action，创建action并将异步请求结果赋值给action.value上】      \n\n​            dispatch(changeArticles(res.data.data.list));     \n\n​        }).catch((error)=>{       \n\n​            console.log(error);     \n\n​        });   \n\n​    }; \n\n}\n```\n\n**react-saga：**\n\n在创建store文件中创建saga中间件\n\n安装react-saga依赖包：\n\n```\n$ yarn add react-saga\n```\n\n在创建store时编写下面代码\n\n```\n// 创建store\nimport { createStore,applyMiddleware,compose } from \'redux’; \nimport reducer from \'./reducers’; \nimport createSagaMiddleware  from \'redux-saga’; \nimport mySagas from \'./mySagas’;\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst sagaMiddleware = createSagaMiddleware(); \n\nconst enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)) \n\nlet store = createStore(reducer,enhancer); \n\n//在这里使用mySagas【在store创建好后，中间件挂好后在使用mySagas】 \n\nsagaMiddleware.run(mySagas);\n\nexport default store;\n```\n\n创建mySagas文件：【组件分发相应的action，mysaga中间件文件根据actionType匹配相应的action执行异步请求后，再次分发action对象，在reducer文件中同步请求更改store中的状态数据】\n\n```\nimport { takeEvery,put } from ‘redux-saga/effects’;\n\n//创建mySagas【generator函数】函数后，在创建store仓库中使用mySagas【saga中间插件调用run方法使用】\nfunction* mySagas(){   // console.log(11111);   \n​    //监听某个action,然后执行第二个参数gengerator函数   \n​    yield takeEvery(GET_DATA_SA_ACTION,getList);   \n}\n\n//参数action就是对应的action对象 \nfunction* getList(action){   \n​    //发送异步，异步成功后分发action   \n​    let res = yield axios.get(url,   {params:action.value});   \n​    //put就是转发action，类似于dispatch，然后执行同步请求执行相应的业务逻辑处理   \n​    yield put(changeArticles(res.data.list)); \n}\n```\n\n', '前端状态数据管理库redux结合react-thunk或react-saga中间件的基本使用', 1584266350598, 1178, 1, 1584266350598);
INSERT INTO `article_content` VALUES (15, 'VSCode常用插件和技巧教程（2）', '  VSCode 想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。  \n## P01：VSCode实现毛玻璃效果\n\n技术胖虽然长的难看，但绝对是喜欢漂亮人和物的，比如说小姐姐。那作为一个前端程序员，肯定也会让自己的VSCode越漂亮越好。这个文章我就介绍一下，如何让VSCode拥有漂亮的毛玻璃效果。\n\n毛玻璃的朦胧美，就仿佛美女穿了黑色的丝袜，非常的诱人心智。\n\nVibrancy\n安装并运行插件\n\n其实要实现这个效果，只需要下载一个插件就可以解决，这个插件就是 Vibrancy。\n\n打开VSCode，然后点击插件栏，搜索插件Vibrancy，搜索到之后，点击install进行安装。\n\nVibrancy\n\n安装好主体后，你需要按F1键,打开命令输入框，然后输入Reload Vibrancy后回车。如果不起作用，你就重新启动一下VSCode.\n\n需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。\n插件设置\n\n这个插件还支持透明度和两款主题样式的设置。设置方法是在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions ，然后再找到Vibrancy Effect进行设置。\n\n一共有三项设置：\n\n    Opacity：透明度设置，这个数值默认为-1，你可以输入自己喜欢的值0-1之间，比如0.8.\n    Theme： 毛玻璃的样式设置，一共有三个样式可选，以后可能还会增加。\n    Type： 这个有很多选项，你可以具体进行测试。\n\n## P02：VSCode里直接预览效果\n\n如果你没有双屏显示器，又不想来回切换窗口，而是直接在VSCode里进行预览，这简直太方便了，剩下的时间看个岛国小电影或者玩两把守望屁股他不香吗?\n\n来来来，快点开始吧，妹子和游戏都在向我招手。\n\nBrowser Preview\n安装Browser Preview\n\n打开插件管理，然后搜索Browser Preview插件，直接进行安装。\n\nBrowser Preview\n\n安装完成后，在Bar上多出一个图标，点击图标就可以在VSCode里打开浏览器了。\n修改默认打开网址\n\n现在的默认地址确实烦人，每次都要重新输入，这是一个有贞操的程序员所不能忍受的。所以我们按住ctrl + ,打开设置，然后找到Extensions,再找到Browser Preview,找到Start Url写上你默认打开的地址就可以了。\n## P03：VSCode一个插件让你的代码更职业\n\n你有没有怀疑过你写的JavaScript代码？如何让自己的代码更专业？VSCode中的JavaScript Booster可以快速提升你的代码专业度。\n\n插件安装完成，不用配置任何东西，就可以使用了。\n\nJavaScript Booster\n插件的基本使用\n\n插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码。\n\n比如我们新建一个js文件，写如下代码：\n\nvar string1= \'jspang.com\';\n\n这时候我们点击var 关键词，JavaScript Booster就会给我们出现黄色小灯泡，我们点击黄色小灯泡后，它会提示我们var可以换成const.直接点击更换。\n\n更换后的代码变成了这个样子。\n\nconst string1= \'jspang.com\';\n\n再比如你写了这样一段代码：\n\nconst gogo = function(str){\n    return \'hi\'+ str\n}\n\n这时候你点击function后，它会出现黄色警告，点击后会提示改为箭头函数，再次点击hi，又会出现警告，说可以使用模板字符串。两次点击后就代码就变成了下面的样子。\n\nconst gogo = str => {\n    return `hi${str}`;\n}\n\n再比如，你要去象牙山洗脚城去大宝剑一下的时候，如果你选择32号就是“刘英”为你服务，如果你选择其它的就是“谢大脚”为你服务。\n\nlet a = 32\nlet str1=\'jspang\'\nif(a===32){\n    str1=\'刘英\'\n}else{\n    str1=\'谢大脚\'\n}\n\n这时候你点击if会提示你改为三元运算符的形式，就变成了这样。\n\nlet a = 32\nlet str1=\'jspang\'\nstr1 = a===32 ? \'刘英\' : \'谢大脚\';\n\n这个插件还有很多转换方式，你可以在写完代码后都点击点击，这样慢慢的你代码水平就会提高。\n## P04：VSCode界面透明插件 程序员上班看片神器\n上次介绍了一个毛玻璃插件，小伙伴都说不太好用，那我这个文章就介绍我的一个我的御用插件`Windows opacity`。有了这个插件，从此上班偷偷看看小姐姐，偷偷看视频时完全可以的。\n\nWindows opacity\n安装并运行插件\n\n安装这个插件是非常简单的，只要打开VSCode,然后点击插件Icon图标，进入插件，在搜索栏上搜索windos opacity,然后找到如图插件，进行安装就可以了。\n\nWindows opacity\n\n安装好后，需要重启一下VSCode，就可以出现透明效果了。\n插件的设置\n\n现在的透明度可能看片还是有一点问题的，那我们就把透明度调的高一点。在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions选项卡，然后找到Windows opacity进行设置。\n\n这里边只有一个设置项，就是Opacity，也就是我们要设置的透明度，值从0-255,数值越小透明度越高，数值越大透明度越低。我一般摸鱼的透明度在230左右，再小就容易被发现了。', '想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。', 1584266350598, 1876, 4, 1587644746000);
INSERT INTO `article_content` VALUES (16, 'Navicat连接腾讯云服务器上的数据库（2）', '## 下面介绍Navicat连接腾讯云服务器上的数据库的两种方法：\n\n## 方法一：【不需要修改相关远程客户端连接权限】\n\n点击安装好的桌面navicat图标，进入后如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214202494-819455691.png)\n\n连接方法：ssh中输入自己服务器的外网ip地址，登录服务器账号和密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214402984-1454339889.png)\n\n \n\n再设置常规属性中，数据库的连接，主机填localhost，因为mysql安装在了本地服务器上，然后填入mysql的用户名及密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214519764-88496090.png)\n\n \n\n \n\n## 方法二：【修改相关MySQL远程客户端连接权限】\n\n下面命令最好在root用户下执行使用：【否则可能会一些文件修改权限受阻问题，需要手动修改用户对文件的使用权限】\n\n#### 1、我们需要更改 3306端口，查看3306 端口是否对外开放，而一般MySQL 默认情况下是不开放对外访问功能的。\n\n使用下面语句进行查询：\n\n \n\n```\n# netstat -an | grep 3306\n```\n\n如果查询结果如下，则需要我们更改 MySQL 配置文件。\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214621204-572794575.png)\n\n查询结果可以看出，MySQL的3306端口只是监听本地的连接，这样就阻碍了外部IP对该数据库的访问，修改 MySQL 配置文件：\n\n```\n# /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在MySQL配置文件中找到  bind-address = 127.0.0.1 这一行\n\n将bind-address = 127.0.0.1 这行注释掉或者改为你想要使用的客户端主机 ip。如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214704648-229822164.png)\n\n \n\n \n\n这样，我们的 MySQL 远程访问端口就开启成功了。\n\n \n\n#### 2、我们进入 MySQL 命令界面，运行下列SQL 语句：\n\n \n\n使用下面命令先在服务器终端上登录mysql的root用户\n\n \n\n```\n# mysql -uroot -p\n```\n\n \n\n然后输入root用户密码就可以登录mysql了\n\n \n\n使用下面命令切换为使用mysql数据库\n\n \n\n```\nmysql> use mysql; \n```\n\n \n\n使用下面命令查看用户是否具有访问权限：\n\n \n\n```\nmysql> select user, host from user;\n```\n\n \n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214823443-1521450522.png)\n\n \n\n上面显示root用户只用访问本地的权限，我们需要通配符 % 来修改 root 用户对应的 host 字段，使其具有访问所有 ip 地址的权限：\n\n```\nmysql> update user set host = \'%\' where user = \'root\';\n```\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214943424-1543189887.png)\n\n \n\n如果抛出如下异常：\n\n```\nDuplicate entry \'%-root\' for key \'PRIMARY\'\n```\n\n说明有多个root用户纪录在user表中了，我们重新执行下面命令就可以看到字段 host 的 % 值：\n\n```\nmysql> select host from user where user = \'root\';\n```\n\n我们执行：\n\n```\nmysql> flush privileges;\n```\n\n刷新一下 MySQL 的系统权限相关表。\n\n下面还要确认的一件事就是确认客户端用户是否具有权限，我们给与他们相应的访问权限：\n\n```\nmysql> grant all privileges on *.* to username@\"%\" identified by \"password\";\n```\n\n最后退出mysql重启一下 MySQL 服务：\n\n```\nmysql> exit;   //退出mysql\n#sudo mysql restart   //重启mysql服务\n```\n\n#### 3、服务端设置好了，我们在 Navicat 客户端设置一下连接：\n\n打开 Navicat软件，点击左上方的 \"连接\"，设置一下数据库的连接名，服务器外网ip地址，mysql用户名及密码等，\n\n点击测试连接成功后再点击确定按钮便能在 Navicat 中远程操作服务器上的 MySQL 了。\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705215031893-1645905718.png)\n\n \n\n \n\n到这里，Navicat连接腾讯云服务器上的数据库的两种方法就结束了，希望可以帮助大家。。。', '介绍Navicat连接腾讯云服务器上的数据库的两种方法', 1586268227000, 1078, 4, 1586268733000);
INSERT INTO `article_content` VALUES (17, 'js数组【续】(相关方法)（2）', '## 一、数组的栈，队列方法【调用这些方法原数组会发生改变】\n\n```\n    var arr = [2,3,4,5,6];\n```\n\n1.栈 LIFO (Last-In-First-Out)\n\n a、push() 可接受任意类型的参数，将它们逐个添加到数组的末尾。【返回数组的长度】\n\n```\n    console.log(arr);  //[2,3,4,5,6]\n    console.log(+arr.push(7)); //返回添加数据后数组的长度：6\n    console.log(arr);  //[2,3,4,5,6,7]\n```\n\nb、pop() 从数组的末尾移除最后一项，减少数组的length值。【返回移除的项】\n\n```\n    console.log(arr.pop()); //取出栈顶元素并返回该栈顶元素值：7\n    console.log(arr);  //[2,3,4,5,6]\n```\n\n2.队列 FIFO (First-In-First-Out)\n\na、shift() 移除数组中的第一个项，同时将数组的长度减一。【返回移除的项】\n\n```\n    console.log(arr.shift()); //hello\n    console.log(arr); //[2,3,4,5,6]\n```\n\nb、unshift() 在数组的前端添加任意个项。【返回数组的长度】\n\n```\n    console.log(arr.unshift(\'hello\')); //6\n    console.log(arr); //[\'hello\',2,3,4,5,6]\n```\n\n## 二、数组的排序方法【reverse()方法、sort()方法】(原数组发生改变)\n\nvar arr = [23,56,12,43,6,23,26];\n\n1、reverse()方法：【对数组项进行反转】\n\n```\n    console.log(arr);\n    //反转 翻转 reverse  改变原数组\n    console.log(arr.reverse());\n    console.log(arr);\n```\n\n2、sort()方法【数组排序,返回排序后的数组】\n\na、sort()不带参数默认为升序\n\n```\n    console.log(arr.sort()); //按照字符串ASSIC码形式比较\n```\n\nb、sort()带指定排序函数\n函数返回值：\n    正值：交换\n    负值：不交换\n\n```\n    console.log(arr.sort(com));\n    console.log(arr);\n    function com(a,b){\n        //return a-b;  //升序\n        //负数a,b不发生交换 a b  a<b 负值  不交换;  a b  a<b  升序排列\n        //正数数a,b不发生交换   a b  a>b 正值  交换;   b  a   b<a  升序排列\n\n        //return b-a;  //降序\n\n        //升序\n        if(a<=b){\n                return -1;  //负数不发生交换\n        }else{\n                return 1;  //正数发生交换\n        }\n```\n\n3、查找最高(最低)的数组值\n\na.使用sort()方法先进行排序，然后再在排好序的数组中取值\nb.使用Math.max.apply()和Math.min.apply()方法\n\n```\n    Math.max.apply(null,array);　　//获取array数组中的最大值\n    Math.min.apply(null,array);　　//获取array数组中的最小值\n```\n\n## 三、截取方法：\n\n1、数组拼接：concat()方法 【不改变原数组】\n\n先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，返回副本数组。\neg:\n\n```\n    var arr = [3,4,5,2,4];\n    var arr2 = [1,2,3,4,5];\n\n    var result = arr.concat(arr2);\n    console.log(arr);    //[3,4,5,2,4]\n    console.log(result);    //[3,4,5,2,4,1,2,3,4,5]\n\n    var result2 = arr.concat(\'hello\');\n    console.log(result2);    //[3,4,5,2,4,\'hello\']\n```\n\n2、数组切割：slice()方法 【不改变原数组】\n\nslice(返回项的起始位置，结束位置);\n一个参数：从该参数指定的位置开始，到当前数组末尾的所有项。\n两个参数：起始到结束之间的项，但是不包含结束位置的项。\neg:\n\n```\n    //参数是一个为从开始位置截取到末尾；参数是两个的，截取部分为开始位置到结束位置不包括结束位置的值\n    //返回截取部分的值,不改变原数组\n    var arr = [123,34,5,67,3,6,8];\n    var result = arr.slice(2);\n    console.log(result);  //[5,67,3,6,8]\n    console.log(arr);  //[123,34,5,67,3,6,8]\n\n    var result2 = arr.slice(2,4);\n    console.log(result2); //[5,67]\n```\n\n3、splice() 【改变原数组】\n\n向数组的中部插入数据将始终返回一个数组，该数组中包含从原始数组中删除的项。\n删除：指定一个参数(删除的开始的位置)【删除该参数索引及后面的所有元素】；指定两个参数(删除的起始位置，要删除的项数) 【返回删除的元素组成的数组】\n插入：指定三个参数(起始位置，0，要插入的项任意数量的项) \n替换：指定三个参数(起始位置，要删除的项数，要插入的任意数量的项)\neg:\n\n```\n    //删除\n    var arr = [32,4,9,3,0];\n    var result = arr.splice(1,3);\n    console.log(result);  //[4,9,3]\n    console.log(arr); //[32,0]\n\n    //插入\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,0,\'hello\',\'sss\');\n    console.log(arr);  //[32,\'hello\',\'sss\',4,9,3,0]\n\n    //替换\n    //从索引位置为1的删除两项后在开始位置处再插入一些元素\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,2,1,2);\n    console.log(arr); //[32,1,2,3,0]\n```\n\n## 四、索引方法\n\nindexOf lastindexOf 返回索引或-1\nvar arr = [2,5,67,\'2\',3,2,45];\n\n1、indexOf() \n\n从数组开头向后查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    //参数：要查找的元素   开始查找的位置\n    console.log(arr.indexOf(2)); //0\n    console.log(arr.indexOf(2,1)); //5\n    console.log(arr.indexOf(22)); //-1\n```\n\n2、lastIndexOf() \n\n从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    console.log(arr.lastIndexOf(2));  //5\n    console.log(arr.lastIndexOf(2,3)); //0\n```\n\n3.常用于判断数组中是否含有该元素\n\n```\n    if(arr.indexOf(2) != -1){ }\n```\n\n## 五、迭代方法\n\n参数： 每一项上运行的函数，运行该函数的作用域对象（可选）\n\n1、every() \n\n对数组中的每一运行给定的函数参数，如果该参数函数对每一项都返回true,则该函数返回true\neg:\n\n```\n    var arr = [23,45,1,4,3,45,7];\n    var result = arr.every(function(item,index,arr){\n        console.log(this); //{}\n        return item>20;\n    },{});\n    console.log(result); //false\n```\n\n2、some(),3、filter(),4、map()使用的数组如下：\n\n```\nvar stus = [\n        {\n                name:\'zhangsan\',\n                age:20\n        },{\n                name:\'lisi\',\n                age:13\n        },{\n                name:\'wangwu\',\n                age:12\n        }\n];\n```\n\n2、some() \n\n对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true\neg：\n\n```\n    //判断是否有未成年人，有返回true，否则返回：false\n    var result = stus.some(function(item,index,arr){\n         return item.age<18\n    });\n    console.log(result); //true\n```\n\n3、filter() \n\n对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组\neg：\n\n```\n    //filter\n    //过滤出来所有成年人\n    var result = stus.filter(function(item,index,arr){\n        return item.age>18;\n    });\n    console.log(result);\n\n    //查找所有未成年人的名字\n    //先过滤出所有未成年人再映射出符合条件人名字\n    var result = stus.filter(function(item,index,arr){\n        return item.age<18;\n    }).map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n```\n\n4、map()\n\n对数组中的每一元素运行给定的函数,返回每次函数调用的结果组成的数组\n\n```\n    //map\n    //查找处所有人的名字,返回数组\n    var result = stus.map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n    var result = stus.map(function(item,index,arr){\n        return item.age*2;\n    });\n    console.log(result);\n```\n\n5、forEach() \n\n对数组中的每一元素运行给定的函数,没有返回值，常用来遍历元素\n\n```\n    //数组的遍历\n    var arr = [{\n        name:\'zhangsan\'\n    },{\n        name:\'lisi\'\n    },{\n        name:\'terry\'\n    }];\n    //向数组各元素对象中添加age属性\n    var ageInit = 10;\n    arr.forEach(function(item,index,arr){\n        item.age = ageInit++;\n    });\n    console.log(arr);\n```\n\n ', 'js数组中一些常用的方法基本使用', 1584547200000, 7823, 3, 1585017659000);
INSERT INTO `article_content` VALUES (18, 'js正则表达式【续】(相关字符的解释含义)（2）', '## 1、字符类\n\n[直接量] \n. (点号，小数点) 匹配任意单个字符，但是行结束符除外  \n\\d 　　匹配一个0-9之间的阿拉伯数字。等价于[0-9]  \n\\D 　   匹配任意一个不是0-9之间阿拉伯数字的字  符。等价于[^0-9]。   \n\\w 　   匹配任意一个字母、数字或下划线的字符。等价于 [A-Za-z0-9_]。   \n\\W　   匹配任意一个不是字母、数字或下划线的字符。等价于 [^A-Za-z0-9_]。   \n\\s 　　匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  \n\\S 　   匹配一个非空白符。  \n\\t 　　 匹配一个水平制表符（tab）   \n\\r 　　 匹配一个回车符（carriage return）   \n\\n 　    匹配一个换行符（linefeed）   \n\\v 　    匹配一个垂直制表符（vertical tab）   \n\\f 　　 匹配一个换页符（form-feed）  \n\n## 2、数量词\n\nx*　　        匹配前面的模式 x 0 或多次。  \nx+ 　　      匹配前面的模式 x 1 或多次。等价于 {1,}。  \nx*? 　　     像上面的 * 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx+? 　　    像上面的 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx? 　　       匹配前面的模式 x 0 或 1 次。  \nx|y 　　      匹配 x 或 y  \nx{n}　　     n 是一个正整数。前面的模式 x 连续出现 n 次时匹配  \nx{n,} 　　   n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。  \nx{n,m}　　 n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。  \n\n## 3、字符集合\n\n[xyz] 　　  一个字符集合(字符组)。匹配集合中的任意一个字符。【你可以使用连字符\'-\'指定一个范围。[0-9] [a-z] [A-Z]】  \n[^xyz] 　　一个反义或补充字符集(反义字符组)。匹配任意不在括号内的字符。【你也可以通过使用连字符 \'-\' 指定一个范围内的字符】  \n\n## 4、边界\n\n^ 　　 匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。  \n$ 　　 匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。  \n\\b 　　匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。  \n\\B　　 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。  \n\n## 5、分组\n\n(x) 　　匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。  \n\\n 　　 n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。  \neg：\n\n```\n    /\\w+:\\/\\/\\w+(.)\\w+\\1\\w+/\n```\n\n\n拓展：  \na.在分组情况中，如果(x)后面有数量词修饰时；它也只算做一个()【括号】来算，而后面使用的\\n来指向正则表达式中该括号时，\n则是指向它重复次数的最后一次()【括号】里面所包含的内容。【可以使用str.match(正则表达式)不带g修饰符来输出进行检测查看】  \nb.\\n后面加数量词修饰则是重复\\n选择的括号里面的字串。  \neg：\n\n```\n    str = \'ababaabaa\'\n    console.log(str.match(/([a-z]).\\1/g));  //[\'aba\',\'aba\']\n    console.log(str.match(/([a-z]){2}.\\1/g));  //[\'abab\',\'aaba\']\n    console.log(str.match(/([a-z]){2}.\\1{2}/g));  //[babaa]\n    console.log(str.match(/([a-z]).\\1{2}/g));  //[\'abaa\']\n```\n', 'js正则表达式中相关字符的解释含义', 1584547200000, 363, 3, 1587642782000);
INSERT INTO `article_content` VALUES (19, 'ES6 变量与解构(二)（2）', '## 一、变量的声明与使用 【测试示例需要在node环境中测试,浏览器环境下并不完全兼容ES6代码】\n\nES6中可以使用 {} 来包含任意一段代码,被 {} 包裹的内容称为一个代码块(局部作用域)\n\nlet关键字　【声明变量】\n特性：\n1.块级作用域    【局部作用于声明的代码块中】\n2.变量声明不会提升    【变量未声明前无法使用该变量】\n3.暂时性死区    【该变量声明前面的区域】\n4.不能重复声明    【同一代码块中不能重复声明同一变量】\n\nconst关键字    【声明常量(一般用大写字母表示常量)】\n特性：【在遵从let声明变量的特性上再添加如下两条特性】\n1、声明时初始化    【声明的同时必须赋值】\n2、值不可修改\n\n## 二、解构\n\n1、数组的解构赋值　【左边是变量,右边是值,左边无匹配值时为undefined】\n完全解构【左右数据恰好匹配】\neg：\n\n```\n    let [a,b,c] = [1,2,3];\n```\n\n\n不完全解构【左右数据不同】\na、左边数据多则只声明该变量,其值为undefined\nb、右边数据多余项则忽视不考虑\neg：\n\n```\n    let [a, [b], d] = [1, [2, 3], 4];     //a = 1; b = 2; d = 4 \n```\n\n\n集合解构【扩展运算符的使用...】\na、...tail返回目前右边未匹配的所有值组成的数组\neg：\n\n```\n    let [head, ...tail] = [1, 2, 3, 4]; //head = 1; tail = [2, 3, 4]\n    //累加操作\n    let sum = 0;\n    function test(...arr){\n        //rest参数【扩展运算符形式接受的参数,返回的为参数数组】 ------>不在推荐使用arguments参数类数组对象\n        //arr = [1,2,3,4,5]\n        for(let i=0;i<arr.length;i++){\n            sum +=arr[i];\n        }\n    }\n    \n    test(1,2,3,4,5);\n```\n\n\n默认值【当匹配值严格等于undefined,默认值生效】\neg：\n\n```\n    let [x, y = \'b\'] = [\'a\']; 　　// x=\'a\', y=\'b’\n```\n\n\n默认值为函数\n注：先判断是否匹配到值,若匹配值严格等于undefined,再进行默认值的赋值运算;否则,默认值赋值操作不会执行\neg：\n\n```\n    function test() {\n        console.log(\'test\');\n        return 2;\n    }\n    let [x = test()] = [];\n    console.log(x);        //test    2\n```\n\n\n    \n2、对象的解构赋值　【右边不存在左边变量对应的属性名时,对象属性值为undefined;即对象中未声明的属性的值为undefined】\n对象原始结构赋值【变量重命名后,最终声明的变量是重命名的变量】\neg：\n\n```\n    let {name:myName,age:myAge} = {name:\'nzc\',age:18}\n    //上面代码类比于下面代码【左边name匹配右边对象中同名属性获取其属性值并赋值给name重命名的myName变量==》将let myName = \'nzc\'】\n    let myName = \'nzc\';\n    let myAge = 18;\n```\n\n​    \n对象的属性没有次序,变量必须与属性同名才能取到正确的值【重命名相同可以简写】\neg：\n\n```\n    let {name:name,age:age} = {name:\'nzc\',age:18}\n    //简写如下\n    let {name,age} = {name:\'nzc\',age:18}\n    //类比于下面代码\n    let name = \'nzc\';\n    let age = 18;\n```\n\n\n对象嵌套解构\neg：\n\n```\n    let person = { param: [ \'nzc\', { age: 18 } ] };\n    let { param: [name, { age }] } = person; //name=\'nzc\' age=18\n    //类比于下面   param变量被重命名为 [name, { age }],所以自身并未声明;即不存在param变量\n    let { param: [name, { age }] } = { param: [ \'nzc\', { age: 18 } ] }\n```\n\n​    \n默认值(默认值生效的条件是，对象的属性值严格等于undefined)\neg：\n\n```\n    //name=\'nzchs\'->name变量默认值;age:myAge=21->myAge默认值【age重命名为myAge再赋予默认值】\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\',age:18}\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\'}  \n```\n\n\n    \n3、字符串的解构赋值\n解构时，字符串被转换成了一个类似数组的对象。\neg：\n\n```\n    let [a, b, c] = \'hello\'; //a=h;b=e;c=l\n```\n\nlength属性解构\neg：\n\n```\n    let {length : len} = \'hello\'; //len = 5 【匹配右边字符串转换为的类数组对象的length属性并将其值赋值给重命名的len变量】\n```\n\n \n\n\n4、数值和布尔值解构赋值\n解构时，如果等号右边是数值和布尔值，则会先转为相应的基本引用数据类型对象\neg：\n\n```\n    let {toString: str1} = 123; //函数 str1 === Number.prototype.toString     返回true\n    let {toString: str2} = true; //函数 str2 === Boolean.prototype.toString        返回true\n```\n\n\n\n5、函数参数的解构赋值\n基本数组解构赋值传参\neg：\n\n```\n    function add([x, y]){ return x + y; }\n    add([1, 2]);   //函数add返回值为3 \n```\n\n\n函数参数带有默认值\neg：\n\n```\n    function test({x = 0, y = 0}) {\n        return [x, y];\n    }\n    //函数调用\n    test({x: 3, y: 8}); // 返回值为[3, 8]\n    test({x: 3}); // 返回值为[3, 0]\n    test({}); // 返回值为[0, 0]\n    test(); //报错 Cannot destructure property `x` of \'undefined\' or \'null\'\n```\n\n## 三、解构常用用途\n\n1、变量值的交换\neg：\n\n```\n    let x = 1;\n    let y = 2;\n    [x,y] = [y,x];  \n    console.log(x,y); //2 1    \n```\n\n2、函数参数的赋值：\neg：\n\n```\n    //[a=0,b=1] = [1]   a=1,b=1\n    function test([a=0,b=1]){\n        return a+b;\n    }\n    test([1]);  //返回值为2\n```\n\n3、提取对象中的数据\neg：\n\n```\n    let obj= { id: 42, status: \"OK\", data: [867, 5309] };\n    let { id, status, data: number } = obj;  //定义对应的变量 \n```\n\n4、输入模块的指定方法\n\n```\n    const { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n5、遍历map结构\n\n```\n    var map = new Map();\n    map.set(\'name\', \'nzc\');\n    map.set(\'age\', 18);\n    for (let [key, value] of map) {\n        console.log(key + \" is \" + value);    // name is nzc   age is 18\n    }\n```\n\n ', 'ES6中定义变量新增关键字及解构的基本用法', 1584720000000, 986, 2, 1585377428000);
INSERT INTO `article_content` VALUES (20, 'react安装配置（2）', '**一、React安装配置**\r\n\r\n使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速\r\n\r\n1、全局安装最新版本的npm依赖包\r\n\r\n```\r\n$ npm install npm@latest -g\r\n```\r\n\r\n2、安装淘宝镜像【从国内存储库中下载相应的依\r\n\r\n```\r\n$ npm install -g cnpm --registry=[https://registry.npm.taobao.org\r\n```\r\n\r\n3、全局安装脚手架\r\n\r\n```\r\n$ cnpm install -g create-react-app my-app\r\n```\r\n\r\n4、进入项目目录\r\n\r\n```\r\n$ cd my-app\r\n```\r\n\r\n5、启动项目\r\n\r\n```\r\n$ yarn start  或者 cnpm start\r\n```\r\n\r\n\r\n\r\n一些需要的依赖包安装：\r\n\r\n1、安装sass包依赖\r\n\r\n```\r\n$ yarn add sass-loader node-sass --save-dev\r\n```\r\n\r\n2、代码规范配置\r\n\r\n3、安装路由依赖包\r\n\r\n```\r\n$ yarn add react-router-dom --save-dev\r\n```\r\n\r\n4、安装js对象与表单格式的转换依赖包\r\n\r\n```\r\n$ yarn add qs --save-dev\r\n```\r\n\r\n5、安装路由机制依赖包\r\n\r\n```\r\nyarn add react-router-dom --save-dev\r\n```\r\n\r\n从依赖包中导入需要使用的路由相关的变量\r\n\r\n```\r\nImport { HashRouter,NavLink,Switch,Route,Redirect } from ‘react-router-dom’;\r\n```\r\n\r\n设置导航及路由组件：\r\n\r\n```\r\n<HashRouter>\r\n\r\n​    <NavLink activeClassName=\"active\" exact to=\"/\">首页</NavLink>\r\n\r\n​    <NavLink activeClassName=\"active\" to=\"/student\">student</NavLink>\r\n\r\n\r\n\r\n​    <Switch>\r\n\r\n​        <Route exact path=\"/\" component={Index}><Route>\r\n\r\n​        <Route path=\"/student\" component={Student}><Route>\r\n\r\n​        <Route path=“/course“ render(()=>{return <div>course</div>})><Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n\r\n\r\n**二、React框架的三大特点：**\r\n\r\n**1、VRDOM【虚拟dom】**\r\n\r\na、首先构建虚拟DOM树并存储于内存中【具有单页面Web应用的一些优缺点】\r\n\r\nb、在页面数据更新时局部渲染页面【使用diff算法比较页面变化前后的两颗VRDOM树只更新渲染改变的部分（数据更新效率更快）】\r\n\r\n\r\n\r\n**2、组件化 -- JSX语法**\r\n\r\na、函数组件（无状态组件）\r\n\r\nb、class类组件（状态组件）\r\n\r\n容器：不可更改的标签元素，也不能定义为组件【容器若更改，它里面的所有后代元素也会重新渲染（需要定制shouldComponentUpdagte()钩子函数或使用hook），所以一般容器标签元素不可更改】\r\n\r\n\r\n\r\n**3、单向数据流**\r\n\r\n数据只能从父组件向子组件传递数据信息\r\n\r\n**父传子：**\r\n\r\n​    父组件将值作为子组件的属性值传递给子组件\r\n\r\n​    子组件通过this.props.attrName获取相应的值\r\n\r\n\r\n\r\n默认情况下会统一同步，父子数据不想要同步时，将传递给子组件的数据存成子组件的state【在组件挂载前保存更新state数据】\r\n\r\n\r\n\r\n**子传父：**\r\n\r\n​    子组件设置一个函数，在函数内部调用父组件的回调函数（this.props.回调函数名）\r\n\r\n​    父组件中设置一个回调函数传递给子组件并通过该函数获取相应子组件传递过来的参数值。\r\n\r\n\r\n\r\n​    ref属性：【不是特殊情况下，一般不建议使用(它是通过获取标签元素来进行的一些相关操作，与react中的VRDOM有点背道而驰)】\r\n\r\n父组件也可以通过this.refs.子组件ref属性值来获取相应的子组件并可以调用子组件中的状态值。\r\n\r\n\r\n\r\n**三、React中动态传参**\r\n\r\n参考链接：<https://www.jianshu.com/p/77467c15a0ce>\r\n\r\n**1、动态路由传参**【推荐使用】\r\n\r\n```\r\n<Link to=\"/student/sam\">学生</Link>\r\n\r\n//或者\r\n\r\nhashHistory.push(“/user/sam”)\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student/:name\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.match.params.name来获取传递过来的name参数值\r\n\r\n**注：**\r\n\r\n​    该方法可以传递一个或多个值，但值的类型都是字符串【传递一个对象时需要将js对象转换成JSON字符串传递】\r\n\r\n**2、查询字符串传参**【不推荐使用：刷新页面参数丢失】\r\n\r\n```\r\n<NavLink to=“student?name=zhangsan&age=21\"></NavLink>\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.location.name\r\n\r\n3、**API传参**【】\r\n\r\n```\r\nthis.props.history.push({\r\n\r\n​    pathname:”/student”,   //跳转的组件路径\r\n\r\n​    payload:”传递的参数\"\r\n\r\n})\r\n\r\nthis.props.location.payload     //获取传递过来的参数数值\r\n```\r\n', '使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速', 1584266350598, 100, 1, 1587644360000);
INSERT INTO `article_content` VALUES (21, 'Redux知识整理（2）', '## 1、创建reducer纯函数【返回最新的状态值state】\n\n创建一个或多个reducer纯函数文件\n\nreducer中设置初始state数据信息\n\n将状态数据state与分发的action对象作为reducer文件中纯函数的两个参数\n\n```\nconst initialState = [];\n\nconst reducer = (state = initialState, action) => {\n\n​    switch() {\n\n​        case ‘reset’:\n\n​            return { ...state, value: action.value };\n\n​        case ‘update’:\n\n​            return Object.assign({}, state, action.payload);\n\n​        default:\n\n​            return state;\n\n​    }\n\n}\n\nexport default reducer;\n```\n\n在获取到分发的action对象匹配对应类型执行相应的业务逻辑处理【更改state中的数据信息】\n\n\n\n## 2、整合reducer\n\n将多个reducer进行整合并可以进行重新命名\n\n```\ncombineReducers({\n\n​    test1:test1Reducer,\n\n​     test2:test2Reducer\n\n})\n```\n\n\n## 3、创建数据源store\n\n将整合的reducer作为createStore()函数的参数创建数据源信息\n\n```\nconst store = createStore(reducer);\n```\n\n**react-redux核心：**<https://www.jianshu.com/p/186956ac666a>\n\n\n\n## 4、Provider组件【容器组件：****负责管理数据和逻辑****】\n\n从react-redux中结构处Provider组件并将其作为整个项目的根元素，将store作为组件的属性向下传递\n\n结合connect函数，后代组件便可以通过props属性获取到store中的数据信息\n\n\n\n## 5、connect函数【连接React组件与Redux store】【展示(UI)组件：****负责 UI 的呈现****】\n\ncoonect函数中的第一个参数包含了原来监听者更新渲染数据的作用【使用connect函数后就不需要再对其另外添加阅读者监听事件渲染更新state】\n\n函数中有两个参数：\n\n参数一:    mapStateToProps函数【将store中的数据作为props绑定到组件上】\n\n```\nmapStateToProps = (state,ownProps)=>{\n\n​    return state;\n\n}\n```\n\n参数二:    mapDispatchTpProps函数【将 action 作为 props 绑定到组件上，也会成为 MyComp 的 props】\n\n```\nmapDispatchToProps = (dispatch,ownProps)=>{    \n\n​    return {\n\n​        changeMsg:()=>{\n\n​            dispatch({\n\n​                type:’CHANGE_MSG’,\n\n​                payload:需要更改的值\n\n​            })\n\n​        }\n\n​    }\n\n}\n```\n\n\n\n## 6、更改或获取store中的state数据\n\n在对应的reducer纯函数中通过分发的action对象执行相应的业务逻辑处理\n\na、判断actiond的type类型，通过action对象中的payload参数信息更新初始state中的数据\n\n\n\n## 7、使用中间件react-thunk或react-saga执行异步请求操作\n\n**在组件js文件中运行相应事件函数分发action**\n\n```\nconst mapDispatchToProps = (dispatch,ownProps) =>{\n\n​    return {\n\n​        getData:()=>{\n\n​            dispatch(getDataAxAction({\n\n​                pageno:1,\n\n​                pagesize:7\n\n​            }));\n\n​        }\n\n​    }\n\n}\n```\n\n**react-thunk：**\n\n在创建store文件中创建thunk中间件\n\n安装react-thunk依赖包：\n\n```\nyarn add react-thunk\n```\n\n**在创建store时编写下面代码**\n\n```\nimport { createStore,applyMiddleware,compose } from \'redux’;\n\nimport thunk from \'redux-thunk’; \n\nimport reducer from \'./reducers’; \n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?       window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; \n\nconst enhancer = composeEnhancers(applyMiddleware(thunk)) \n\nlet store = createStore(reducer,window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); let store = createStore(reducer,enhancer); \n\nexport default store;\n```\n\nreact-thunk异步请求在创建actio文件中创建执行【创建action函数并返回一个函数(可以进行异步请求操作)】\n\n// redux-thunk actionCreator【创建的action函数可以返回一个函数(即可以调用axios执行异步请求数据操作)】\n\n```\nexport const getDataAxAction = (value)=>{   \n\n​    return (dispatch)=>{     \n\n​        axios.get(\'http://134.175.154.93:8099/manager/article/findArticle’, {params:value}).then((res)=>{       \n\n​            //res.data.data.list【获取到查询结果后再次分发action，创建action并将异步请求结果赋值给action.value上】      \n\n​            dispatch(changeArticles(res.data.data.list));     \n\n​        }).catch((error)=>{       \n\n​            console.log(error);     \n\n​        });   \n\n​    }; \n\n}\n```\n\n**react-saga：**\n\n在创建store文件中创建saga中间件\n\n安装react-saga依赖包：\n\n```\n$ yarn add react-saga\n```\n\n在创建store时编写下面代码\n\n```\n// 创建store\nimport { createStore,applyMiddleware,compose } from \'redux’; \nimport reducer from \'./reducers’; \nimport createSagaMiddleware  from \'redux-saga’; \nimport mySagas from \'./mySagas’;\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst sagaMiddleware = createSagaMiddleware(); \n\nconst enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)) \n\nlet store = createStore(reducer,enhancer); \n\n//在这里使用mySagas【在store创建好后，中间件挂好后在使用mySagas】 \n\nsagaMiddleware.run(mySagas);\n\nexport default store;\n```\n\n创建mySagas文件：【组件分发相应的action，mysaga中间件文件根据actionType匹配相应的action执行异步请求后，再次分发action对象，在reducer文件中同步请求更改store中的状态数据】\n\n```\nimport { takeEvery,put } from ‘redux-saga/effects’;\n\n//创建mySagas【generator函数】函数后，在创建store仓库中使用mySagas【saga中间插件调用run方法使用】\nfunction* mySagas(){   // console.log(11111);   \n​    //监听某个action,然后执行第二个参数gengerator函数   \n​    yield takeEvery(GET_DATA_SA_ACTION,getList);   \n}\n\n//参数action就是对应的action对象 \nfunction* getList(action){   \n​    //发送异步，异步成功后分发action   \n​    let res = yield axios.get(url,   {params:action.value});   \n​    //put就是转发action，类似于dispatch，然后执行同步请求执行相应的业务逻辑处理   \n​    yield put(changeArticles(res.data.list)); \n}\n```\n\n', '前端状态数据管理库redux结合react-thunk或react-saga中间件的基本使用', 1584266350598, 3241, 1, 1584266350598);
INSERT INTO `article_content` VALUES (22, 'VSCode常用插件和技巧教程（3）', '  VSCode 想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。  \n## P01：VSCode实现毛玻璃效果\n\n技术胖虽然长的难看，但绝对是喜欢漂亮人和物的，比如说小姐姐。那作为一个前端程序员，肯定也会让自己的VSCode越漂亮越好。这个文章我就介绍一下，如何让VSCode拥有漂亮的毛玻璃效果。\n\n毛玻璃的朦胧美，就仿佛美女穿了黑色的丝袜，非常的诱人心智。\n\nVibrancy\n安装并运行插件\n\n其实要实现这个效果，只需要下载一个插件就可以解决，这个插件就是 Vibrancy。\n\n打开VSCode，然后点击插件栏，搜索插件Vibrancy，搜索到之后，点击install进行安装。\n\nVibrancy\n\n安装好主体后，你需要按F1键,打开命令输入框，然后输入Reload Vibrancy后回车。如果不起作用，你就重新启动一下VSCode.\n\n需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。\n插件设置\n\n这个插件还支持透明度和两款主题样式的设置。设置方法是在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions ，然后再找到Vibrancy Effect进行设置。\n\n一共有三项设置：\n\n    Opacity：透明度设置，这个数值默认为-1，你可以输入自己喜欢的值0-1之间，比如0.8.\n    Theme： 毛玻璃的样式设置，一共有三个样式可选，以后可能还会增加。\n    Type： 这个有很多选项，你可以具体进行测试。\n\n## P02：VSCode里直接预览效果\n\n如果你没有双屏显示器，又不想来回切换窗口，而是直接在VSCode里进行预览，这简直太方便了，剩下的时间看个岛国小电影或者玩两把守望屁股他不香吗?\n\n来来来，快点开始吧，妹子和游戏都在向我招手。\n\nBrowser Preview\n安装Browser Preview\n\n打开插件管理，然后搜索Browser Preview插件，直接进行安装。\n\nBrowser Preview\n\n安装完成后，在Bar上多出一个图标，点击图标就可以在VSCode里打开浏览器了。\n修改默认打开网址\n\n现在的默认地址确实烦人，每次都要重新输入，这是一个有贞操的程序员所不能忍受的。所以我们按住ctrl + ,打开设置，然后找到Extensions,再找到Browser Preview,找到Start Url写上你默认打开的地址就可以了。\n## P03：VSCode一个插件让你的代码更职业\n\n你有没有怀疑过你写的JavaScript代码？如何让自己的代码更专业？VSCode中的JavaScript Booster可以快速提升你的代码专业度。\n\n插件安装完成，不用配置任何东西，就可以使用了。\n\nJavaScript Booster\n插件的基本使用\n\n插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码。\n\n比如我们新建一个js文件，写如下代码：\n\nvar string1= \'jspang.com\';\n\n这时候我们点击var 关键词，JavaScript Booster就会给我们出现黄色小灯泡，我们点击黄色小灯泡后，它会提示我们var可以换成const.直接点击更换。\n\n更换后的代码变成了这个样子。\n\nconst string1= \'jspang.com\';\n\n再比如你写了这样一段代码：\n\nconst gogo = function(str){\n    return \'hi\'+ str\n}\n\n这时候你点击function后，它会出现黄色警告，点击后会提示改为箭头函数，再次点击hi，又会出现警告，说可以使用模板字符串。两次点击后就代码就变成了下面的样子。\n\nconst gogo = str => {\n    return `hi${str}`;\n}\n\n再比如，你要去象牙山洗脚城去大宝剑一下的时候，如果你选择32号就是“刘英”为你服务，如果你选择其它的就是“谢大脚”为你服务。\n\nlet a = 32\nlet str1=\'jspang\'\nif(a===32){\n    str1=\'刘英\'\n}else{\n    str1=\'谢大脚\'\n}\n\n这时候你点击if会提示你改为三元运算符的形式，就变成了这样。\n\nlet a = 32\nlet str1=\'jspang\'\nstr1 = a===32 ? \'刘英\' : \'谢大脚\';\n\n这个插件还有很多转换方式，你可以在写完代码后都点击点击，这样慢慢的你代码水平就会提高。\n## P04：VSCode界面透明插件 程序员上班看片神器\n上次介绍了一个毛玻璃插件，小伙伴都说不太好用，那我这个文章就介绍我的一个我的御用插件`Windows opacity`。有了这个插件，从此上班偷偷看看小姐姐，偷偷看视频时完全可以的。\n\nWindows opacity\n安装并运行插件\n\n安装这个插件是非常简单的，只要打开VSCode,然后点击插件Icon图标，进入插件，在搜索栏上搜索windos opacity,然后找到如图插件，进行安装就可以了。\n\nWindows opacity\n\n安装好后，需要重启一下VSCode，就可以出现透明效果了。\n插件的设置\n\n现在的透明度可能看片还是有一点问题的，那我们就把透明度调的高一点。在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions选项卡，然后找到Windows opacity进行设置。\n\n这里边只有一个设置项，就是Opacity，也就是我们要设置的透明度，值从0-255,数值越小透明度越高，数值越大透明度越低。我一般摸鱼的透明度在230左右，再小就容易被发现了。', '想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。', 1584266350598, 1876, 4, 1587644746000);
INSERT INTO `article_content` VALUES (23, 'Navicat连接腾讯云服务器上的数据库（3）', '## 下面介绍Navicat连接腾讯云服务器上的数据库的两种方法：\n\n## 方法一：【不需要修改相关远程客户端连接权限】\n\n点击安装好的桌面navicat图标，进入后如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214202494-819455691.png)\n\n连接方法：ssh中输入自己服务器的外网ip地址，登录服务器账号和密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214402984-1454339889.png)\n\n \n\n再设置常规属性中，数据库的连接，主机填localhost，因为mysql安装在了本地服务器上，然后填入mysql的用户名及密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214519764-88496090.png)\n\n \n\n \n\n## 方法二：【修改相关MySQL远程客户端连接权限】\n\n下面命令最好在root用户下执行使用：【否则可能会一些文件修改权限受阻问题，需要手动修改用户对文件的使用权限】\n\n#### 1、我们需要更改 3306端口，查看3306 端口是否对外开放，而一般MySQL 默认情况下是不开放对外访问功能的。\n\n使用下面语句进行查询：\n\n \n\n```\n# netstat -an | grep 3306\n```\n\n如果查询结果如下，则需要我们更改 MySQL 配置文件。\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214621204-572794575.png)\n\n查询结果可以看出，MySQL的3306端口只是监听本地的连接，这样就阻碍了外部IP对该数据库的访问，修改 MySQL 配置文件：\n\n```\n# /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在MySQL配置文件中找到  bind-address = 127.0.0.1 这一行\n\n将bind-address = 127.0.0.1 这行注释掉或者改为你想要使用的客户端主机 ip。如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214704648-229822164.png)\n\n \n\n \n\n这样，我们的 MySQL 远程访问端口就开启成功了。\n\n \n\n#### 2、我们进入 MySQL 命令界面，运行下列SQL 语句：\n\n \n\n使用下面命令先在服务器终端上登录mysql的root用户\n\n \n\n```\n# mysql -uroot -p\n```\n\n \n\n然后输入root用户密码就可以登录mysql了\n\n \n\n使用下面命令切换为使用mysql数据库\n\n \n\n```\nmysql> use mysql; \n```\n\n \n\n使用下面命令查看用户是否具有访问权限：\n\n \n\n```\nmysql> select user, host from user;\n```\n\n \n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214823443-1521450522.png)\n\n \n\n上面显示root用户只用访问本地的权限，我们需要通配符 % 来修改 root 用户对应的 host 字段，使其具有访问所有 ip 地址的权限：\n\n```\nmysql> update user set host = \'%\' where user = \'root\';\n```\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214943424-1543189887.png)\n\n \n\n如果抛出如下异常：\n\n```\nDuplicate entry \'%-root\' for key \'PRIMARY\'\n```\n\n说明有多个root用户纪录在user表中了，我们重新执行下面命令就可以看到字段 host 的 % 值：\n\n```\nmysql> select host from user where user = \'root\';\n```\n\n我们执行：\n\n```\nmysql> flush privileges;\n```\n\n刷新一下 MySQL 的系统权限相关表。\n\n下面还要确认的一件事就是确认客户端用户是否具有权限，我们给与他们相应的访问权限：\n\n```\nmysql> grant all privileges on *.* to username@\"%\" identified by \"password\";\n```\n\n最后退出mysql重启一下 MySQL 服务：\n\n```\nmysql> exit;   //退出mysql\n#sudo mysql restart   //重启mysql服务\n```\n\n#### 3、服务端设置好了，我们在 Navicat 客户端设置一下连接：\n\n打开 Navicat软件，点击左上方的 \"连接\"，设置一下数据库的连接名，服务器外网ip地址，mysql用户名及密码等，\n\n点击测试连接成功后再点击确定按钮便能在 Navicat 中远程操作服务器上的 MySQL 了。\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705215031893-1645905718.png)\n\n \n\n \n\n到这里，Navicat连接腾讯云服务器上的数据库的两种方法就结束了，希望可以帮助大家。。。', '介绍Navicat连接腾讯云服务器上的数据库的两种方法', 1586268227000, 1078, 4, 1586268733000);
INSERT INTO `article_content` VALUES (24, 'js数组【续】(相关方法)（3）', '## 一、数组的栈，队列方法【调用这些方法原数组会发生改变】\n\n```\n    var arr = [2,3,4,5,6];\n```\n\n1.栈 LIFO (Last-In-First-Out)\n\n a、push() 可接受任意类型的参数，将它们逐个添加到数组的末尾。【返回数组的长度】\n\n```\n    console.log(arr);  //[2,3,4,5,6]\n    console.log(+arr.push(7)); //返回添加数据后数组的长度：6\n    console.log(arr);  //[2,3,4,5,6,7]\n```\n\nb、pop() 从数组的末尾移除最后一项，减少数组的length值。【返回移除的项】\n\n```\n    console.log(arr.pop()); //取出栈顶元素并返回该栈顶元素值：7\n    console.log(arr);  //[2,3,4,5,6]\n```\n\n2.队列 FIFO (First-In-First-Out)\n\na、shift() 移除数组中的第一个项，同时将数组的长度减一。【返回移除的项】\n\n```\n    console.log(arr.shift()); //hello\n    console.log(arr); //[2,3,4,5,6]\n```\n\nb、unshift() 在数组的前端添加任意个项。【返回数组的长度】\n\n```\n    console.log(arr.unshift(\'hello\')); //6\n    console.log(arr); //[\'hello\',2,3,4,5,6]\n```\n\n## 二、数组的排序方法【reverse()方法、sort()方法】(原数组发生改变)\n\nvar arr = [23,56,12,43,6,23,26];\n\n1、reverse()方法：【对数组项进行反转】\n\n```\n    console.log(arr);\n    //反转 翻转 reverse  改变原数组\n    console.log(arr.reverse());\n    console.log(arr);\n```\n\n2、sort()方法【数组排序,返回排序后的数组】\n\na、sort()不带参数默认为升序\n\n```\n    console.log(arr.sort()); //按照字符串ASSIC码形式比较\n```\n\nb、sort()带指定排序函数\n函数返回值：\n    正值：交换\n    负值：不交换\n\n```\n    console.log(arr.sort(com));\n    console.log(arr);\n    function com(a,b){\n        //return a-b;  //升序\n        //负数a,b不发生交换 a b  a<b 负值  不交换;  a b  a<b  升序排列\n        //正数数a,b不发生交换   a b  a>b 正值  交换;   b  a   b<a  升序排列\n\n        //return b-a;  //降序\n\n        //升序\n        if(a<=b){\n                return -1;  //负数不发生交换\n        }else{\n                return 1;  //正数发生交换\n        }\n```\n\n3、查找最高(最低)的数组值\n\na.使用sort()方法先进行排序，然后再在排好序的数组中取值\nb.使用Math.max.apply()和Math.min.apply()方法\n\n```\n    Math.max.apply(null,array);　　//获取array数组中的最大值\n    Math.min.apply(null,array);　　//获取array数组中的最小值\n```\n\n## 三、截取方法：\n\n1、数组拼接：concat()方法 【不改变原数组】\n\n先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，返回副本数组。\neg:\n\n```\n    var arr = [3,4,5,2,4];\n    var arr2 = [1,2,3,4,5];\n\n    var result = arr.concat(arr2);\n    console.log(arr);    //[3,4,5,2,4]\n    console.log(result);    //[3,4,5,2,4,1,2,3,4,5]\n\n    var result2 = arr.concat(\'hello\');\n    console.log(result2);    //[3,4,5,2,4,\'hello\']\n```\n\n2、数组切割：slice()方法 【不改变原数组】\n\nslice(返回项的起始位置，结束位置);\n一个参数：从该参数指定的位置开始，到当前数组末尾的所有项。\n两个参数：起始到结束之间的项，但是不包含结束位置的项。\neg:\n\n```\n    //参数是一个为从开始位置截取到末尾；参数是两个的，截取部分为开始位置到结束位置不包括结束位置的值\n    //返回截取部分的值,不改变原数组\n    var arr = [123,34,5,67,3,6,8];\n    var result = arr.slice(2);\n    console.log(result);  //[5,67,3,6,8]\n    console.log(arr);  //[123,34,5,67,3,6,8]\n\n    var result2 = arr.slice(2,4);\n    console.log(result2); //[5,67]\n```\n\n3、splice() 【改变原数组】\n\n向数组的中部插入数据将始终返回一个数组，该数组中包含从原始数组中删除的项。\n删除：指定一个参数(删除的开始的位置)【删除该参数索引及后面的所有元素】；指定两个参数(删除的起始位置，要删除的项数) 【返回删除的元素组成的数组】\n插入：指定三个参数(起始位置，0，要插入的项任意数量的项) \n替换：指定三个参数(起始位置，要删除的项数，要插入的任意数量的项)\neg:\n\n```\n    //删除\n    var arr = [32,4,9,3,0];\n    var result = arr.splice(1,3);\n    console.log(result);  //[4,9,3]\n    console.log(arr); //[32,0]\n\n    //插入\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,0,\'hello\',\'sss\');\n    console.log(arr);  //[32,\'hello\',\'sss\',4,9,3,0]\n\n    //替换\n    //从索引位置为1的删除两项后在开始位置处再插入一些元素\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,2,1,2);\n    console.log(arr); //[32,1,2,3,0]\n```\n\n## 四、索引方法\n\nindexOf lastindexOf 返回索引或-1\nvar arr = [2,5,67,\'2\',3,2,45];\n\n1、indexOf() \n\n从数组开头向后查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    //参数：要查找的元素   开始查找的位置\n    console.log(arr.indexOf(2)); //0\n    console.log(arr.indexOf(2,1)); //5\n    console.log(arr.indexOf(22)); //-1\n```\n\n2、lastIndexOf() \n\n从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    console.log(arr.lastIndexOf(2));  //5\n    console.log(arr.lastIndexOf(2,3)); //0\n```\n\n3.常用于判断数组中是否含有该元素\n\n```\n    if(arr.indexOf(2) != -1){ }\n```\n\n## 五、迭代方法\n\n参数： 每一项上运行的函数，运行该函数的作用域对象（可选）\n\n1、every() \n\n对数组中的每一运行给定的函数参数，如果该参数函数对每一项都返回true,则该函数返回true\neg:\n\n```\n    var arr = [23,45,1,4,3,45,7];\n    var result = arr.every(function(item,index,arr){\n        console.log(this); //{}\n        return item>20;\n    },{});\n    console.log(result); //false\n```\n\n2、some(),3、filter(),4、map()使用的数组如下：\n\n```\nvar stus = [\n        {\n                name:\'zhangsan\',\n                age:20\n        },{\n                name:\'lisi\',\n                age:13\n        },{\n                name:\'wangwu\',\n                age:12\n        }\n];\n```\n\n2、some() \n\n对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true\neg：\n\n```\n    //判断是否有未成年人，有返回true，否则返回：false\n    var result = stus.some(function(item,index,arr){\n         return item.age<18\n    });\n    console.log(result); //true\n```\n\n3、filter() \n\n对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组\neg：\n\n```\n    //filter\n    //过滤出来所有成年人\n    var result = stus.filter(function(item,index,arr){\n        return item.age>18;\n    });\n    console.log(result);\n\n    //查找所有未成年人的名字\n    //先过滤出所有未成年人再映射出符合条件人名字\n    var result = stus.filter(function(item,index,arr){\n        return item.age<18;\n    }).map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n```\n\n4、map()\n\n对数组中的每一元素运行给定的函数,返回每次函数调用的结果组成的数组\n\n```\n    //map\n    //查找处所有人的名字,返回数组\n    var result = stus.map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n    var result = stus.map(function(item,index,arr){\n        return item.age*2;\n    });\n    console.log(result);\n```\n\n5、forEach() \n\n对数组中的每一元素运行给定的函数,没有返回值，常用来遍历元素\n\n```\n    //数组的遍历\n    var arr = [{\n        name:\'zhangsan\'\n    },{\n        name:\'lisi\'\n    },{\n        name:\'terry\'\n    }];\n    //向数组各元素对象中添加age属性\n    var ageInit = 10;\n    arr.forEach(function(item,index,arr){\n        item.age = ageInit++;\n    });\n    console.log(arr);\n```\n\n ', 'js数组中一些常用的方法基本使用', 1584547200000, 1276, 3, 1585017659000);
INSERT INTO `article_content` VALUES (25, 'js正则表达式【续】(相关字符的解释含义)（3）', '## 1、字符类\n\n[直接量] \n. (点号，小数点) 匹配任意单个字符，但是行结束符除外  \n\\d 　　匹配一个0-9之间的阿拉伯数字。等价于[0-9]  \n\\D 　   匹配任意一个不是0-9之间阿拉伯数字的字  符。等价于[^0-9]。   \n\\w 　   匹配任意一个字母、数字或下划线的字符。等价于 [A-Za-z0-9_]。   \n\\W　   匹配任意一个不是字母、数字或下划线的字符。等价于 [^A-Za-z0-9_]。   \n\\s 　　匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  \n\\S 　   匹配一个非空白符。  \n\\t 　　 匹配一个水平制表符（tab）   \n\\r 　　 匹配一个回车符（carriage return）   \n\\n 　    匹配一个换行符（linefeed）   \n\\v 　    匹配一个垂直制表符（vertical tab）   \n\\f 　　 匹配一个换页符（form-feed）  \n\n## 2、数量词\n\nx*　　        匹配前面的模式 x 0 或多次。  \nx+ 　　      匹配前面的模式 x 1 或多次。等价于 {1,}。  \nx*? 　　     像上面的 * 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx+? 　　    像上面的 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx? 　　       匹配前面的模式 x 0 或 1 次。  \nx|y 　　      匹配 x 或 y  \nx{n}　　     n 是一个正整数。前面的模式 x 连续出现 n 次时匹配  \nx{n,} 　　   n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。  \nx{n,m}　　 n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。  \n\n## 3、字符集合\n\n[xyz] 　　  一个字符集合(字符组)。匹配集合中的任意一个字符。【你可以使用连字符\'-\'指定一个范围。[0-9] [a-z] [A-Z]】  \n[^xyz] 　　一个反义或补充字符集(反义字符组)。匹配任意不在括号内的字符。【你也可以通过使用连字符 \'-\' 指定一个范围内的字符】  \n\n## 4、边界\n\n^ 　　 匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。  \n$ 　　 匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。  \n\\b 　　匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。  \n\\B　　 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。  \n\n## 5、分组\n\n(x) 　　匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。  \n\\n 　　 n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。  \neg：\n\n```\n    /\\w+:\\/\\/\\w+(.)\\w+\\1\\w+/\n```\n\n\n拓展：  \na.在分组情况中，如果(x)后面有数量词修饰时；它也只算做一个()【括号】来算，而后面使用的\\n来指向正则表达式中该括号时，\n则是指向它重复次数的最后一次()【括号】里面所包含的内容。【可以使用str.match(正则表达式)不带g修饰符来输出进行检测查看】  \nb.\\n后面加数量词修饰则是重复\\n选择的括号里面的字串。  \neg：\n\n```\n    str = \'ababaabaa\'\n    console.log(str.match(/([a-z]).\\1/g));  //[\'aba\',\'aba\']\n    console.log(str.match(/([a-z]){2}.\\1/g));  //[\'abab\',\'aaba\']\n    console.log(str.match(/([a-z]){2}.\\1{2}/g));  //[babaa]\n    console.log(str.match(/([a-z]).\\1{2}/g));  //[\'abaa\']\n```\n', 'js正则表达式中相关字符的解释含义', 1584547200000, 348, 3, 1587642782000);
INSERT INTO `article_content` VALUES (26, 'ES6 变量与解构(二)（3）', '## 一、变量的声明与使用 【测试示例需要在node环境中测试,浏览器环境下并不完全兼容ES6代码】\n\nES6中可以使用 {} 来包含任意一段代码,被 {} 包裹的内容称为一个代码块(局部作用域)\n\nlet关键字　【声明变量】\n特性：\n1.块级作用域    【局部作用于声明的代码块中】\n2.变量声明不会提升    【变量未声明前无法使用该变量】\n3.暂时性死区    【该变量声明前面的区域】\n4.不能重复声明    【同一代码块中不能重复声明同一变量】\n\nconst关键字    【声明常量(一般用大写字母表示常量)】\n特性：【在遵从let声明变量的特性上再添加如下两条特性】\n1、声明时初始化    【声明的同时必须赋值】\n2、值不可修改\n\n## 二、解构\n\n1、数组的解构赋值　【左边是变量,右边是值,左边无匹配值时为undefined】\n完全解构【左右数据恰好匹配】\neg：\n\n```\n    let [a,b,c] = [1,2,3];\n```\n\n\n不完全解构【左右数据不同】\na、左边数据多则只声明该变量,其值为undefined\nb、右边数据多余项则忽视不考虑\neg：\n\n```\n    let [a, [b], d] = [1, [2, 3], 4];     //a = 1; b = 2; d = 4 \n```\n\n\n集合解构【扩展运算符的使用...】\na、...tail返回目前右边未匹配的所有值组成的数组\neg：\n\n```\n    let [head, ...tail] = [1, 2, 3, 4]; //head = 1; tail = [2, 3, 4]\n    //累加操作\n    let sum = 0;\n    function test(...arr){\n        //rest参数【扩展运算符形式接受的参数,返回的为参数数组】 ------>不在推荐使用arguments参数类数组对象\n        //arr = [1,2,3,4,5]\n        for(let i=0;i<arr.length;i++){\n            sum +=arr[i];\n        }\n    }\n    \n    test(1,2,3,4,5);\n```\n\n\n默认值【当匹配值严格等于undefined,默认值生效】\neg：\n\n```\n    let [x, y = \'b\'] = [\'a\']; 　　// x=\'a\', y=\'b’\n```\n\n\n默认值为函数\n注：先判断是否匹配到值,若匹配值严格等于undefined,再进行默认值的赋值运算;否则,默认值赋值操作不会执行\neg：\n\n```\n    function test() {\n        console.log(\'test\');\n        return 2;\n    }\n    let [x = test()] = [];\n    console.log(x);        //test    2\n```\n\n\n    \n2、对象的解构赋值　【右边不存在左边变量对应的属性名时,对象属性值为undefined;即对象中未声明的属性的值为undefined】\n对象原始结构赋值【变量重命名后,最终声明的变量是重命名的变量】\neg：\n\n```\n    let {name:myName,age:myAge} = {name:\'nzc\',age:18}\n    //上面代码类比于下面代码【左边name匹配右边对象中同名属性获取其属性值并赋值给name重命名的myName变量==》将let myName = \'nzc\'】\n    let myName = \'nzc\';\n    let myAge = 18;\n```\n\n​    \n对象的属性没有次序,变量必须与属性同名才能取到正确的值【重命名相同可以简写】\neg：\n\n```\n    let {name:name,age:age} = {name:\'nzc\',age:18}\n    //简写如下\n    let {name,age} = {name:\'nzc\',age:18}\n    //类比于下面代码\n    let name = \'nzc\';\n    let age = 18;\n```\n\n\n对象嵌套解构\neg：\n\n```\n    let person = { param: [ \'nzc\', { age: 18 } ] };\n    let { param: [name, { age }] } = person; //name=\'nzc\' age=18\n    //类比于下面   param变量被重命名为 [name, { age }],所以自身并未声明;即不存在param变量\n    let { param: [name, { age }] } = { param: [ \'nzc\', { age: 18 } ] }\n```\n\n​    \n默认值(默认值生效的条件是，对象的属性值严格等于undefined)\neg：\n\n```\n    //name=\'nzchs\'->name变量默认值;age:myAge=21->myAge默认值【age重命名为myAge再赋予默认值】\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\',age:18}\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\'}  \n```\n\n\n    \n3、字符串的解构赋值\n解构时，字符串被转换成了一个类似数组的对象。\neg：\n\n```\n    let [a, b, c] = \'hello\'; //a=h;b=e;c=l\n```\n\nlength属性解构\neg：\n\n```\n    let {length : len} = \'hello\'; //len = 5 【匹配右边字符串转换为的类数组对象的length属性并将其值赋值给重命名的len变量】\n```\n\n \n\n\n4、数值和布尔值解构赋值\n解构时，如果等号右边是数值和布尔值，则会先转为相应的基本引用数据类型对象\neg：\n\n```\n    let {toString: str1} = 123; //函数 str1 === Number.prototype.toString     返回true\n    let {toString: str2} = true; //函数 str2 === Boolean.prototype.toString        返回true\n```\n\n\n\n5、函数参数的解构赋值\n基本数组解构赋值传参\neg：\n\n```\n    function add([x, y]){ return x + y; }\n    add([1, 2]);   //函数add返回值为3 \n```\n\n\n函数参数带有默认值\neg：\n\n```\n    function test({x = 0, y = 0}) {\n        return [x, y];\n    }\n    //函数调用\n    test({x: 3, y: 8}); // 返回值为[3, 8]\n    test({x: 3}); // 返回值为[3, 0]\n    test({}); // 返回值为[0, 0]\n    test(); //报错 Cannot destructure property `x` of \'undefined\' or \'null\'\n```\n\n## 三、解构常用用途\n\n1、变量值的交换\neg：\n\n```\n    let x = 1;\n    let y = 2;\n    [x,y] = [y,x];  \n    console.log(x,y); //2 1    \n```\n\n2、函数参数的赋值：\neg：\n\n```\n    //[a=0,b=1] = [1]   a=1,b=1\n    function test([a=0,b=1]){\n        return a+b;\n    }\n    test([1]);  //返回值为2\n```\n\n3、提取对象中的数据\neg：\n\n```\n    let obj= { id: 42, status: \"OK\", data: [867, 5309] };\n    let { id, status, data: number } = obj;  //定义对应的变量 \n```\n\n4、输入模块的指定方法\n\n```\n    const { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n5、遍历map结构\n\n```\n    var map = new Map();\n    map.set(\'name\', \'nzc\');\n    map.set(\'age\', 18);\n    for (let [key, value] of map) {\n        console.log(key + \" is \" + value);    // name is nzc   age is 18\n    }\n```\n\n ', 'ES6中定义变量新增关键字及解构的基本用法', 1584720000000, 986, 2, 1585377428000);
INSERT INTO `article_content` VALUES (27, 'react安装配置（3）', '**一、React安装配置**\r\n\r\n使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速\r\n\r\n1、全局安装最新版本的npm依赖包\r\n\r\n```\r\n$ npm install npm@latest -g\r\n```\r\n\r\n2、安装淘宝镜像【从国内存储库中下载相应的依\r\n\r\n```\r\n$ npm install -g cnpm --registry=[https://registry.npm.taobao.org\r\n```\r\n\r\n3、全局安装脚手架\r\n\r\n```\r\n$ cnpm install -g create-react-app my-app\r\n```\r\n\r\n4、进入项目目录\r\n\r\n```\r\n$ cd my-app\r\n```\r\n\r\n5、启动项目\r\n\r\n```\r\n$ yarn start  或者 cnpm start\r\n```\r\n\r\n\r\n\r\n一些需要的依赖包安装：\r\n\r\n1、安装sass包依赖\r\n\r\n```\r\n$ yarn add sass-loader node-sass --save-dev\r\n```\r\n\r\n2、代码规范配置\r\n\r\n3、安装路由依赖包\r\n\r\n```\r\n$ yarn add react-router-dom --save-dev\r\n```\r\n\r\n4、安装js对象与表单格式的转换依赖包\r\n\r\n```\r\n$ yarn add qs --save-dev\r\n```\r\n\r\n5、安装路由机制依赖包\r\n\r\n```\r\nyarn add react-router-dom --save-dev\r\n```\r\n\r\n从依赖包中导入需要使用的路由相关的变量\r\n\r\n```\r\nImport { HashRouter,NavLink,Switch,Route,Redirect } from ‘react-router-dom’;\r\n```\r\n\r\n设置导航及路由组件：\r\n\r\n```\r\n<HashRouter>\r\n\r\n​    <NavLink activeClassName=\"active\" exact to=\"/\">首页</NavLink>\r\n\r\n​    <NavLink activeClassName=\"active\" to=\"/student\">student</NavLink>\r\n\r\n\r\n\r\n​    <Switch>\r\n\r\n​        <Route exact path=\"/\" component={Index}><Route>\r\n\r\n​        <Route path=\"/student\" component={Student}><Route>\r\n\r\n​        <Route path=“/course“ render(()=>{return <div>course</div>})><Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n\r\n\r\n**二、React框架的三大特点：**\r\n\r\n**1、VRDOM【虚拟dom】**\r\n\r\na、首先构建虚拟DOM树并存储于内存中【具有单页面Web应用的一些优缺点】\r\n\r\nb、在页面数据更新时局部渲染页面【使用diff算法比较页面变化前后的两颗VRDOM树只更新渲染改变的部分（数据更新效率更快）】\r\n\r\n\r\n\r\n**2、组件化 -- JSX语法**\r\n\r\na、函数组件（无状态组件）\r\n\r\nb、class类组件（状态组件）\r\n\r\n容器：不可更改的标签元素，也不能定义为组件【容器若更改，它里面的所有后代元素也会重新渲染（需要定制shouldComponentUpdagte()钩子函数或使用hook），所以一般容器标签元素不可更改】\r\n\r\n\r\n\r\n**3、单向数据流**\r\n\r\n数据只能从父组件向子组件传递数据信息\r\n\r\n**父传子：**\r\n\r\n​    父组件将值作为子组件的属性值传递给子组件\r\n\r\n​    子组件通过this.props.attrName获取相应的值\r\n\r\n\r\n\r\n默认情况下会统一同步，父子数据不想要同步时，将传递给子组件的数据存成子组件的state【在组件挂载前保存更新state数据】\r\n\r\n\r\n\r\n**子传父：**\r\n\r\n​    子组件设置一个函数，在函数内部调用父组件的回调函数（this.props.回调函数名）\r\n\r\n​    父组件中设置一个回调函数传递给子组件并通过该函数获取相应子组件传递过来的参数值。\r\n\r\n\r\n\r\n​    ref属性：【不是特殊情况下，一般不建议使用(它是通过获取标签元素来进行的一些相关操作，与react中的VRDOM有点背道而驰)】\r\n\r\n父组件也可以通过this.refs.子组件ref属性值来获取相应的子组件并可以调用子组件中的状态值。\r\n\r\n\r\n\r\n**三、React中动态传参**\r\n\r\n参考链接：<https://www.jianshu.com/p/77467c15a0ce>\r\n\r\n**1、动态路由传参**【推荐使用】\r\n\r\n```\r\n<Link to=\"/student/sam\">学生</Link>\r\n\r\n//或者\r\n\r\nhashHistory.push(“/user/sam”)\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student/:name\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.match.params.name来获取传递过来的name参数值\r\n\r\n**注：**\r\n\r\n​    该方法可以传递一个或多个值，但值的类型都是字符串【传递一个对象时需要将js对象转换成JSON字符串传递】\r\n\r\n**2、查询字符串传参**【不推荐使用：刷新页面参数丢失】\r\n\r\n```\r\n<NavLink to=“student?name=zhangsan&age=21\"></NavLink>\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.location.name\r\n\r\n3、**API传参**【】\r\n\r\n```\r\nthis.props.history.push({\r\n\r\n​    pathname:”/student”,   //跳转的组件路径\r\n\r\n​    payload:”传递的参数\"\r\n\r\n})\r\n\r\nthis.props.location.payload     //获取传递过来的参数数值\r\n```\r\n', '使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速', 1584266350598, 1341, 1, 1587644360000);
INSERT INTO `article_content` VALUES (28, 'Redux知识整理（3）', '## 1、创建reducer纯函数【返回最新的状态值state】\n\n创建一个或多个reducer纯函数文件\n\nreducer中设置初始state数据信息\n\n将状态数据state与分发的action对象作为reducer文件中纯函数的两个参数\n\n```\nconst initialState = [];\n\nconst reducer = (state = initialState, action) => {\n\n​    switch() {\n\n​        case ‘reset’:\n\n​            return { ...state, value: action.value };\n\n​        case ‘update’:\n\n​            return Object.assign({}, state, action.payload);\n\n​        default:\n\n​            return state;\n\n​    }\n\n}\n\nexport default reducer;\n```\n\n在获取到分发的action对象匹配对应类型执行相应的业务逻辑处理【更改state中的数据信息】\n\n\n\n## 2、整合reducer\n\n将多个reducer进行整合并可以进行重新命名\n\n```\ncombineReducers({\n\n​    test1:test1Reducer,\n\n​     test2:test2Reducer\n\n})\n```\n\n\n## 3、创建数据源store\n\n将整合的reducer作为createStore()函数的参数创建数据源信息\n\n```\nconst store = createStore(reducer);\n```\n\n**react-redux核心：**<https://www.jianshu.com/p/186956ac666a>\n\n\n\n## 4、Provider组件【容器组件：****负责管理数据和逻辑****】\n\n从react-redux中结构处Provider组件并将其作为整个项目的根元素，将store作为组件的属性向下传递\n\n结合connect函数，后代组件便可以通过props属性获取到store中的数据信息\n\n\n\n## 5、connect函数【连接React组件与Redux store】【展示(UI)组件：****负责 UI 的呈现****】\n\ncoonect函数中的第一个参数包含了原来监听者更新渲染数据的作用【使用connect函数后就不需要再对其另外添加阅读者监听事件渲染更新state】\n\n函数中有两个参数：\n\n参数一:    mapStateToProps函数【将store中的数据作为props绑定到组件上】\n\n```\nmapStateToProps = (state,ownProps)=>{\n\n​    return state;\n\n}\n```\n\n参数二:    mapDispatchTpProps函数【将 action 作为 props 绑定到组件上，也会成为 MyComp 的 props】\n\n```\nmapDispatchToProps = (dispatch,ownProps)=>{    \n\n​    return {\n\n​        changeMsg:()=>{\n\n​            dispatch({\n\n​                type:’CHANGE_MSG’,\n\n​                payload:需要更改的值\n\n​            })\n\n​        }\n\n​    }\n\n}\n```\n\n\n\n## 6、更改或获取store中的state数据\n\n在对应的reducer纯函数中通过分发的action对象执行相应的业务逻辑处理\n\na、判断actiond的type类型，通过action对象中的payload参数信息更新初始state中的数据\n\n\n\n## 7、使用中间件react-thunk或react-saga执行异步请求操作\n\n**在组件js文件中运行相应事件函数分发action**\n\n```\nconst mapDispatchToProps = (dispatch,ownProps) =>{\n\n​    return {\n\n​        getData:()=>{\n\n​            dispatch(getDataAxAction({\n\n​                pageno:1,\n\n​                pagesize:7\n\n​            }));\n\n​        }\n\n​    }\n\n}\n```\n\n**react-thunk：**\n\n在创建store文件中创建thunk中间件\n\n安装react-thunk依赖包：\n\n```\nyarn add react-thunk\n```\n\n**在创建store时编写下面代码**\n\n```\nimport { createStore,applyMiddleware,compose } from \'redux’;\n\nimport thunk from \'redux-thunk’; \n\nimport reducer from \'./reducers’; \n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?       window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; \n\nconst enhancer = composeEnhancers(applyMiddleware(thunk)) \n\nlet store = createStore(reducer,window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); let store = createStore(reducer,enhancer); \n\nexport default store;\n```\n\nreact-thunk异步请求在创建actio文件中创建执行【创建action函数并返回一个函数(可以进行异步请求操作)】\n\n// redux-thunk actionCreator【创建的action函数可以返回一个函数(即可以调用axios执行异步请求数据操作)】\n\n```\nexport const getDataAxAction = (value)=>{   \n\n​    return (dispatch)=>{     \n\n​        axios.get(\'http://134.175.154.93:8099/manager/article/findArticle’, {params:value}).then((res)=>{       \n\n​            //res.data.data.list【获取到查询结果后再次分发action，创建action并将异步请求结果赋值给action.value上】      \n\n​            dispatch(changeArticles(res.data.data.list));     \n\n​        }).catch((error)=>{       \n\n​            console.log(error);     \n\n​        });   \n\n​    }; \n\n}\n```\n\n**react-saga：**\n\n在创建store文件中创建saga中间件\n\n安装react-saga依赖包：\n\n```\n$ yarn add react-saga\n```\n\n在创建store时编写下面代码\n\n```\n// 创建store\nimport { createStore,applyMiddleware,compose } from \'redux’; \nimport reducer from \'./reducers’; \nimport createSagaMiddleware  from \'redux-saga’; \nimport mySagas from \'./mySagas’;\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst sagaMiddleware = createSagaMiddleware(); \n\nconst enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)) \n\nlet store = createStore(reducer,enhancer); \n\n//在这里使用mySagas【在store创建好后，中间件挂好后在使用mySagas】 \n\nsagaMiddleware.run(mySagas);\n\nexport default store;\n```\n\n创建mySagas文件：【组件分发相应的action，mysaga中间件文件根据actionType匹配相应的action执行异步请求后，再次分发action对象，在reducer文件中同步请求更改store中的状态数据】\n\n```\nimport { takeEvery,put } from ‘redux-saga/effects’;\n\n//创建mySagas【generator函数】函数后，在创建store仓库中使用mySagas【saga中间插件调用run方法使用】\nfunction* mySagas(){   // console.log(11111);   \n​    //监听某个action,然后执行第二个参数gengerator函数   \n​    yield takeEvery(GET_DATA_SA_ACTION,getList);   \n}\n\n//参数action就是对应的action对象 \nfunction* getList(action){   \n​    //发送异步，异步成功后分发action   \n​    let res = yield axios.get(url,   {params:action.value});   \n​    //put就是转发action，类似于dispatch，然后执行同步请求执行相应的业务逻辑处理   \n​    yield put(changeArticles(res.data.list)); \n}\n```\n\n', '前端状态数据管理库redux结合react-thunk或react-saga中间件的基本使用', 1584266350598, 3421, 1, 1584266350598);
INSERT INTO `article_content` VALUES (29, 'VSCode常用插件和技巧教程（4）', '  VSCode 想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。  \n## P01：VSCode实现毛玻璃效果\n\n技术胖虽然长的难看，但绝对是喜欢漂亮人和物的，比如说小姐姐。那作为一个前端程序员，肯定也会让自己的VSCode越漂亮越好。这个文章我就介绍一下，如何让VSCode拥有漂亮的毛玻璃效果。\n\n毛玻璃的朦胧美，就仿佛美女穿了黑色的丝袜，非常的诱人心智。\n\nVibrancy\n安装并运行插件\n\n其实要实现这个效果，只需要下载一个插件就可以解决，这个插件就是 Vibrancy。\n\n打开VSCode，然后点击插件栏，搜索插件Vibrancy，搜索到之后，点击install进行安装。\n\nVibrancy\n\n安装好主体后，你需要按F1键,打开命令输入框，然后输入Reload Vibrancy后回车。如果不起作用，你就重新启动一下VSCode.\n\n需要注意的一点是，这个插件每次更新VSCode就要重新运行Reload Vibrancy。\n插件设置\n\n这个插件还支持透明度和两款主题样式的设置。设置方法是在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions ，然后再找到Vibrancy Effect进行设置。\n\n一共有三项设置：\n\n    Opacity：透明度设置，这个数值默认为-1，你可以输入自己喜欢的值0-1之间，比如0.8.\n    Theme： 毛玻璃的样式设置，一共有三个样式可选，以后可能还会增加。\n    Type： 这个有很多选项，你可以具体进行测试。\n\n## P02：VSCode里直接预览效果\n\n如果你没有双屏显示器，又不想来回切换窗口，而是直接在VSCode里进行预览，这简直太方便了，剩下的时间看个岛国小电影或者玩两把守望屁股他不香吗?\n\n来来来，快点开始吧，妹子和游戏都在向我招手。\n\nBrowser Preview\n安装Browser Preview\n\n打开插件管理，然后搜索Browser Preview插件，直接进行安装。\n\nBrowser Preview\n\n安装完成后，在Bar上多出一个图标，点击图标就可以在VSCode里打开浏览器了。\n修改默认打开网址\n\n现在的默认地址确实烦人，每次都要重新输入，这是一个有贞操的程序员所不能忍受的。所以我们按住ctrl + ,打开设置，然后找到Extensions,再找到Browser Preview,找到Start Url写上你默认打开的地址就可以了。\n## P03：VSCode一个插件让你的代码更职业\n\n你有没有怀疑过你写的JavaScript代码？如何让自己的代码更专业？VSCode中的JavaScript Booster可以快速提升你的代码专业度。\n\n插件安装完成，不用配置任何东西，就可以使用了。\n\nJavaScript Booster\n插件的基本使用\n\n插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码。\n\n比如我们新建一个js文件，写如下代码：\n\nvar string1= \'jspang.com\';\n\n这时候我们点击var 关键词，JavaScript Booster就会给我们出现黄色小灯泡，我们点击黄色小灯泡后，它会提示我们var可以换成const.直接点击更换。\n\n更换后的代码变成了这个样子。\n\nconst string1= \'jspang.com\';\n\n再比如你写了这样一段代码：\n\nconst gogo = function(str){\n    return \'hi\'+ str\n}\n\n这时候你点击function后，它会出现黄色警告，点击后会提示改为箭头函数，再次点击hi，又会出现警告，说可以使用模板字符串。两次点击后就代码就变成了下面的样子。\n\nconst gogo = str => {\n    return `hi${str}`;\n}\n\n再比如，你要去象牙山洗脚城去大宝剑一下的时候，如果你选择32号就是“刘英”为你服务，如果你选择其它的就是“谢大脚”为你服务。\n\nlet a = 32\nlet str1=\'jspang\'\nif(a===32){\n    str1=\'刘英\'\n}else{\n    str1=\'谢大脚\'\n}\n\n这时候你点击if会提示你改为三元运算符的形式，就变成了这样。\n\nlet a = 32\nlet str1=\'jspang\'\nstr1 = a===32 ? \'刘英\' : \'谢大脚\';\n\n这个插件还有很多转换方式，你可以在写完代码后都点击点击，这样慢慢的你代码水平就会提高。\n## P04：VSCode界面透明插件 程序员上班看片神器\n上次介绍了一个毛玻璃插件，小伙伴都说不太好用，那我这个文章就介绍我的一个我的御用插件`Windows opacity`。有了这个插件，从此上班偷偷看看小姐姐，偷偷看视频时完全可以的。\n\nWindows opacity\n安装并运行插件\n\n安装这个插件是非常简单的，只要打开VSCode,然后点击插件Icon图标，进入插件，在搜索栏上搜索windos opacity,然后找到如图插件，进行安装就可以了。\n\nWindows opacity\n\n安装好后，需要重启一下VSCode，就可以出现透明效果了。\n插件的设置\n\n现在的透明度可能看片还是有一点问题的，那我们就把透明度调的高一点。在VSCode中使用快捷键Ctrl + ,,打开设置界面，在左边找到Extensions选项卡，然后找到Windows opacity进行设置。\n\n这里边只有一个设置项，就是Opacity，也就是我们要设置的透明度，值从0-255,数值越小透明度越高，数值越大透明度越低。我一般摸鱼的透明度在230左右，再小就容易被发现了。', '想写这个文章已经很久了，但是一直觉的需要的人可能会很少，毕竟VSCode这种每天都使用IDE工具，基本在1小时内就可以快速上手，但是通过我对身边同事的观察，我发现还是有很多小伙伴使用不够精通。特别是现在越来越多的插件，有的非常好用，直接可以提高我们的开发效率，那从今天开始，我开始更新VSCode的一些插件和技巧，这个并不是定期更新，而是我有了好的素材就会更新。', 1584266350598, 1143, 4, 1587644746000);
INSERT INTO `article_content` VALUES (30, 'Navicat连接腾讯云服务器上的数据库（4）', '## 下面介绍Navicat连接腾讯云服务器上的数据库的两种方法：\n\n## 方法一：【不需要修改相关远程客户端连接权限】\n\n点击安装好的桌面navicat图标，进入后如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214202494-819455691.png)\n\n连接方法：ssh中输入自己服务器的外网ip地址，登录服务器账号和密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214402984-1454339889.png)\n\n \n\n再设置常规属性中，数据库的连接，主机填localhost，因为mysql安装在了本地服务器上，然后填入mysql的用户名及密码\n\n如下图：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214519764-88496090.png)\n\n \n\n \n\n## 方法二：【修改相关MySQL远程客户端连接权限】\n\n下面命令最好在root用户下执行使用：【否则可能会一些文件修改权限受阻问题，需要手动修改用户对文件的使用权限】\n\n#### 1、我们需要更改 3306端口，查看3306 端口是否对外开放，而一般MySQL 默认情况下是不开放对外访问功能的。\n\n使用下面语句进行查询：\n\n \n\n```\n# netstat -an | grep 3306\n```\n\n如果查询结果如下，则需要我们更改 MySQL 配置文件。\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214621204-572794575.png)\n\n查询结果可以看出，MySQL的3306端口只是监听本地的连接，这样就阻碍了外部IP对该数据库的访问，修改 MySQL 配置文件：\n\n```\n# /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n在MySQL配置文件中找到  bind-address = 127.0.0.1 这一行\n\n将bind-address = 127.0.0.1 这行注释掉或者改为你想要使用的客户端主机 ip。如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214704648-229822164.png)\n\n \n\n \n\n这样，我们的 MySQL 远程访问端口就开启成功了。\n\n \n\n#### 2、我们进入 MySQL 命令界面，运行下列SQL 语句：\n\n \n\n使用下面命令先在服务器终端上登录mysql的root用户\n\n \n\n```\n# mysql -uroot -p\n```\n\n \n\n然后输入root用户密码就可以登录mysql了\n\n \n\n使用下面命令切换为使用mysql数据库\n\n \n\n```\nmysql> use mysql; \n```\n\n \n\n使用下面命令查看用户是否具有访问权限：\n\n \n\n```\nmysql> select user, host from user;\n```\n\n \n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214823443-1521450522.png)\n\n \n\n上面显示root用户只用访问本地的权限，我们需要通配符 % 来修改 root 用户对应的 host 字段，使其具有访问所有 ip 地址的权限：\n\n```\nmysql> update user set host = \'%\' where user = \'root\';\n```\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705214943424-1543189887.png)\n\n \n\n如果抛出如下异常：\n\n```\nDuplicate entry \'%-root\' for key \'PRIMARY\'\n```\n\n说明有多个root用户纪录在user表中了，我们重新执行下面命令就可以看到字段 host 的 % 值：\n\n```\nmysql> select host from user where user = \'root\';\n```\n\n我们执行：\n\n```\nmysql> flush privileges;\n```\n\n刷新一下 MySQL 的系统权限相关表。\n\n下面还要确认的一件事就是确认客户端用户是否具有权限，我们给与他们相应的访问权限：\n\n```\nmysql> grant all privileges on *.* to username@\"%\" identified by \"password\";\n```\n\n最后退出mysql重启一下 MySQL 服务：\n\n```\nmysql> exit;   //退出mysql\n#sudo mysql restart   //重启mysql服务\n```\n\n#### 3、服务端设置好了，我们在 Navicat 客户端设置一下连接：\n\n打开 Navicat软件，点击左上方的 \"连接\"，设置一下数据库的连接名，服务器外网ip地址，mysql用户名及密码等，\n\n点击测试连接成功后再点击确定按钮便能在 Navicat 中远程操作服务器上的 MySQL 了。\n\n如下图所示：\n\n![img](https://img2018.cnblogs.com/blog/1656952/201907/1656952-20190705215031893-1645905718.png)\n\n \n\n \n\n到这里，Navicat连接腾讯云服务器上的数据库的两种方法就结束了，希望可以帮助大家。。。', '介绍Navicat连接腾讯云服务器上的数据库的两种方法', 1586268227000, 478, 4, 1586268733000);
INSERT INTO `article_content` VALUES (31, 'js数组【续】(相关方法)（4）', '## 一、数组的栈，队列方法【调用这些方法原数组会发生改变】\n\n```\n    var arr = [2,3,4,5,6];\n```\n\n1.栈 LIFO (Last-In-First-Out)\n\n a、push() 可接受任意类型的参数，将它们逐个添加到数组的末尾。【返回数组的长度】\n\n```\n    console.log(arr);  //[2,3,4,5,6]\n    console.log(+arr.push(7)); //返回添加数据后数组的长度：6\n    console.log(arr);  //[2,3,4,5,6,7]\n```\n\nb、pop() 从数组的末尾移除最后一项，减少数组的length值。【返回移除的项】\n\n```\n    console.log(arr.pop()); //取出栈顶元素并返回该栈顶元素值：7\n    console.log(arr);  //[2,3,4,5,6]\n```\n\n2.队列 FIFO (First-In-First-Out)\n\na、shift() 移除数组中的第一个项，同时将数组的长度减一。【返回移除的项】\n\n```\n    console.log(arr.shift()); //hello\n    console.log(arr); //[2,3,4,5,6]\n```\n\nb、unshift() 在数组的前端添加任意个项。【返回数组的长度】\n\n```\n    console.log(arr.unshift(\'hello\')); //6\n    console.log(arr); //[\'hello\',2,3,4,5,6]\n```\n\n## 二、数组的排序方法【reverse()方法、sort()方法】(原数组发生改变)\n\nvar arr = [23,56,12,43,6,23,26];\n\n1、reverse()方法：【对数组项进行反转】\n\n```\n    console.log(arr);\n    //反转 翻转 reverse  改变原数组\n    console.log(arr.reverse());\n    console.log(arr);\n```\n\n2、sort()方法【数组排序,返回排序后的数组】\n\na、sort()不带参数默认为升序\n\n```\n    console.log(arr.sort()); //按照字符串ASSIC码形式比较\n```\n\nb、sort()带指定排序函数\n函数返回值：\n    正值：交换\n    负值：不交换\n\n```\n    console.log(arr.sort(com));\n    console.log(arr);\n    function com(a,b){\n        //return a-b;  //升序\n        //负数a,b不发生交换 a b  a<b 负值  不交换;  a b  a<b  升序排列\n        //正数数a,b不发生交换   a b  a>b 正值  交换;   b  a   b<a  升序排列\n\n        //return b-a;  //降序\n\n        //升序\n        if(a<=b){\n                return -1;  //负数不发生交换\n        }else{\n                return 1;  //正数发生交换\n        }\n```\n\n3、查找最高(最低)的数组值\n\na.使用sort()方法先进行排序，然后再在排好序的数组中取值\nb.使用Math.max.apply()和Math.min.apply()方法\n\n```\n    Math.max.apply(null,array);　　//获取array数组中的最大值\n    Math.min.apply(null,array);　　//获取array数组中的最小值\n```\n\n## 三、截取方法：\n\n1、数组拼接：concat()方法 【不改变原数组】\n\n先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，返回副本数组。\neg:\n\n```\n    var arr = [3,4,5,2,4];\n    var arr2 = [1,2,3,4,5];\n\n    var result = arr.concat(arr2);\n    console.log(arr);    //[3,4,5,2,4]\n    console.log(result);    //[3,4,5,2,4,1,2,3,4,5]\n\n    var result2 = arr.concat(\'hello\');\n    console.log(result2);    //[3,4,5,2,4,\'hello\']\n```\n\n2、数组切割：slice()方法 【不改变原数组】\n\nslice(返回项的起始位置，结束位置);\n一个参数：从该参数指定的位置开始，到当前数组末尾的所有项。\n两个参数：起始到结束之间的项，但是不包含结束位置的项。\neg:\n\n```\n    //参数是一个为从开始位置截取到末尾；参数是两个的，截取部分为开始位置到结束位置不包括结束位置的值\n    //返回截取部分的值,不改变原数组\n    var arr = [123,34,5,67,3,6,8];\n    var result = arr.slice(2);\n    console.log(result);  //[5,67,3,6,8]\n    console.log(arr);  //[123,34,5,67,3,6,8]\n\n    var result2 = arr.slice(2,4);\n    console.log(result2); //[5,67]\n```\n\n3、splice() 【改变原数组】\n\n向数组的中部插入数据将始终返回一个数组，该数组中包含从原始数组中删除的项。\n删除：指定一个参数(删除的开始的位置)【删除该参数索引及后面的所有元素】；指定两个参数(删除的起始位置，要删除的项数) 【返回删除的元素组成的数组】\n插入：指定三个参数(起始位置，0，要插入的项任意数量的项) \n替换：指定三个参数(起始位置，要删除的项数，要插入的任意数量的项)\neg:\n\n```\n    //删除\n    var arr = [32,4,9,3,0];\n    var result = arr.splice(1,3);\n    console.log(result);  //[4,9,3]\n    console.log(arr); //[32,0]\n\n    //插入\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,0,\'hello\',\'sss\');\n    console.log(arr);  //[32,\'hello\',\'sss\',4,9,3,0]\n\n    //替换\n    //从索引位置为1的删除两项后在开始位置处再插入一些元素\n　　 var arr = [32,4,9,3,0];\n    arr.splice(1,2,1,2);\n    console.log(arr); //[32,1,2,3,0]\n```\n\n## 四、索引方法\n\nindexOf lastindexOf 返回索引或-1\nvar arr = [2,5,67,\'2\',3,2,45];\n\n1、indexOf() \n\n从数组开头向后查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    //参数：要查找的元素   开始查找的位置\n    console.log(arr.indexOf(2)); //0\n    console.log(arr.indexOf(2,1)); //5\n    console.log(arr.indexOf(22)); //-1\n```\n\n2、lastIndexOf() \n\n从数组末尾向前查找，使用全等操作符，找不到该元素返回-1。\n参数：第一个参数为要查找的项，第二个参数（可选）为索引开始位置\n\n```\n    console.log(arr.lastIndexOf(2));  //5\n    console.log(arr.lastIndexOf(2,3)); //0\n```\n\n3.常用于判断数组中是否含有该元素\n\n```\n    if(arr.indexOf(2) != -1){ }\n```\n\n## 五、迭代方法\n\n参数： 每一项上运行的函数，运行该函数的作用域对象（可选）\n\n1、every() \n\n对数组中的每一运行给定的函数参数，如果该参数函数对每一项都返回true,则该函数返回true\neg:\n\n```\n    var arr = [23,45,1,4,3,45,7];\n    var result = arr.every(function(item,index,arr){\n        console.log(this); //{}\n        return item>20;\n    },{});\n    console.log(result); //false\n```\n\n2、some(),3、filter(),4、map()使用的数组如下：\n\n```\nvar stus = [\n        {\n                name:\'zhangsan\',\n                age:20\n        },{\n                name:\'lisi\',\n                age:13\n        },{\n                name:\'wangwu\',\n                age:12\n        }\n];\n```\n\n2、some() \n\n对数组中的每一运行给定的函数，如果该函数对任一项都返回true,则返回true\neg：\n\n```\n    //判断是否有未成年人，有返回true，否则返回：false\n    var result = stus.some(function(item,index,arr){\n         return item.age<18\n    });\n    console.log(result); //true\n```\n\n3、filter() \n\n对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组\neg：\n\n```\n    //filter\n    //过滤出来所有成年人\n    var result = stus.filter(function(item,index,arr){\n        return item.age>18;\n    });\n    console.log(result);\n\n    //查找所有未成年人的名字\n    //先过滤出所有未成年人再映射出符合条件人名字\n    var result = stus.filter(function(item,index,arr){\n        return item.age<18;\n    }).map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n```\n\n4、map()\n\n对数组中的每一元素运行给定的函数,返回每次函数调用的结果组成的数组\n\n```\n    //map\n    //查找处所有人的名字,返回数组\n    var result = stus.map(function(item,index,arr){\n        return item.name;\n    });\n    console.log(result);\n    var result = stus.map(function(item,index,arr){\n        return item.age*2;\n    });\n    console.log(result);\n```\n\n5、forEach() \n\n对数组中的每一元素运行给定的函数,没有返回值，常用来遍历元素\n\n```\n    //数组的遍历\n    var arr = [{\n        name:\'zhangsan\'\n    },{\n        name:\'lisi\'\n    },{\n        name:\'terry\'\n    }];\n    //向数组各元素对象中添加age属性\n    var ageInit = 10;\n    arr.forEach(function(item,index,arr){\n        item.age = ageInit++;\n    });\n    console.log(arr);\n```\n\n ', 'js数组中一些常用的方法基本使用', 1584547200000, 234, 3, 1585017659000);
INSERT INTO `article_content` VALUES (32, 'js正则表达式【续】(相关字符的解释含义)（4）', '## 1、字符类\n\n[直接量] \n. (点号，小数点) 匹配任意单个字符，但是行结束符除外  \n\\d 　　匹配一个0-9之间的阿拉伯数字。等价于[0-9]  \n\\D 　   匹配任意一个不是0-9之间阿拉伯数字的字  符。等价于[^0-9]。   \n\\w 　   匹配任意一个字母、数字或下划线的字符。等价于 [A-Za-z0-9_]。   \n\\W　   匹配任意一个不是字母、数字或下划线的字符。等价于 [^A-Za-z0-9_]。   \n\\s 　　匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。  \n\\S 　   匹配一个非空白符。  \n\\t 　　 匹配一个水平制表符（tab）   \n\\r 　　 匹配一个回车符（carriage return）   \n\\n 　    匹配一个换行符（linefeed）   \n\\v 　    匹配一个垂直制表符（vertical tab）   \n\\f 　　 匹配一个换页符（form-feed）  \n\n## 2、数量词\n\nx*　　        匹配前面的模式 x 0 或多次。  \nx+ 　　      匹配前面的模式 x 1 或多次。等价于 {1,}。  \nx*? 　　     像上面的 * 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx+? 　　    像上面的 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。【非贪婪模式：优先匹配最小的次数】  \nx? 　　       匹配前面的模式 x 0 或 1 次。  \nx|y 　　      匹配 x 或 y  \nx{n}　　     n 是一个正整数。前面的模式 x 连续出现 n 次时匹配  \nx{n,} 　　   n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。  \nx{n,m}　　 n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。  \n\n## 3、字符集合\n\n[xyz] 　　  一个字符集合(字符组)。匹配集合中的任意一个字符。【你可以使用连字符\'-\'指定一个范围。[0-9] [a-z] [A-Z]】  \n[^xyz] 　　一个反义或补充字符集(反义字符组)。匹配任意不在括号内的字符。【你也可以通过使用连字符 \'-\' 指定一个范围内的字符】  \n\n## 4、边界\n\n^ 　　 匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。  \n$ 　　 匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。  \n\\b 　　匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。  \n\\B　　 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。  \n\n## 5、分组\n\n(x) 　　匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。  \n\\n 　　 n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。  \neg：\n\n```\n    /\\w+:\\/\\/\\w+(.)\\w+\\1\\w+/\n```\n\n\n拓展：  \na.在分组情况中，如果(x)后面有数量词修饰时；它也只算做一个()【括号】来算，而后面使用的\\n来指向正则表达式中该括号时，\n则是指向它重复次数的最后一次()【括号】里面所包含的内容。【可以使用str.match(正则表达式)不带g修饰符来输出进行检测查看】  \nb.\\n后面加数量词修饰则是重复\\n选择的括号里面的字串。  \neg：\n\n```\n    str = \'ababaabaa\'\n    console.log(str.match(/([a-z]).\\1/g));  //[\'aba\',\'aba\']\n    console.log(str.match(/([a-z]){2}.\\1/g));  //[\'abab\',\'aaba\']\n    console.log(str.match(/([a-z]){2}.\\1{2}/g));  //[babaa]\n    console.log(str.match(/([a-z]).\\1{2}/g));  //[\'abaa\']\n```\n', 'js正则表达式中相关字符的解释含义', 1584547200000, 348, 3, 1587642782000);
INSERT INTO `article_content` VALUES (33, 'ES6 变量与解构(二)（4）', '## 一、变量的声明与使用 【测试示例需要在node环境中测试,浏览器环境下并不完全兼容ES6代码】\n\nES6中可以使用 {} 来包含任意一段代码,被 {} 包裹的内容称为一个代码块(局部作用域)\n\nlet关键字　【声明变量】\n特性：\n1.块级作用域    【局部作用于声明的代码块中】\n2.变量声明不会提升    【变量未声明前无法使用该变量】\n3.暂时性死区    【该变量声明前面的区域】\n4.不能重复声明    【同一代码块中不能重复声明同一变量】\n\nconst关键字    【声明常量(一般用大写字母表示常量)】\n特性：【在遵从let声明变量的特性上再添加如下两条特性】\n1、声明时初始化    【声明的同时必须赋值】\n2、值不可修改\n\n## 二、解构\n\n1、数组的解构赋值　【左边是变量,右边是值,左边无匹配值时为undefined】\n完全解构【左右数据恰好匹配】\neg：\n\n```\n    let [a,b,c] = [1,2,3];\n```\n\n\n不完全解构【左右数据不同】\na、左边数据多则只声明该变量,其值为undefined\nb、右边数据多余项则忽视不考虑\neg：\n\n```\n    let [a, [b], d] = [1, [2, 3], 4];     //a = 1; b = 2; d = 4 \n```\n\n\n集合解构【扩展运算符的使用...】\na、...tail返回目前右边未匹配的所有值组成的数组\neg：\n\n```\n    let [head, ...tail] = [1, 2, 3, 4]; //head = 1; tail = [2, 3, 4]\n    //累加操作\n    let sum = 0;\n    function test(...arr){\n        //rest参数【扩展运算符形式接受的参数,返回的为参数数组】 ------>不在推荐使用arguments参数类数组对象\n        //arr = [1,2,3,4,5]\n        for(let i=0;i<arr.length;i++){\n            sum +=arr[i];\n        }\n    }\n    \n    test(1,2,3,4,5);\n```\n\n\n默认值【当匹配值严格等于undefined,默认值生效】\neg：\n\n```\n    let [x, y = \'b\'] = [\'a\']; 　　// x=\'a\', y=\'b’\n```\n\n\n默认值为函数\n注：先判断是否匹配到值,若匹配值严格等于undefined,再进行默认值的赋值运算;否则,默认值赋值操作不会执行\neg：\n\n```\n    function test() {\n        console.log(\'test\');\n        return 2;\n    }\n    let [x = test()] = [];\n    console.log(x);        //test    2\n```\n\n\n    \n2、对象的解构赋值　【右边不存在左边变量对应的属性名时,对象属性值为undefined;即对象中未声明的属性的值为undefined】\n对象原始结构赋值【变量重命名后,最终声明的变量是重命名的变量】\neg：\n\n```\n    let {name:myName,age:myAge} = {name:\'nzc\',age:18}\n    //上面代码类比于下面代码【左边name匹配右边对象中同名属性获取其属性值并赋值给name重命名的myName变量==》将let myName = \'nzc\'】\n    let myName = \'nzc\';\n    let myAge = 18;\n```\n\n​    \n对象的属性没有次序,变量必须与属性同名才能取到正确的值【重命名相同可以简写】\neg：\n\n```\n    let {name:name,age:age} = {name:\'nzc\',age:18}\n    //简写如下\n    let {name,age} = {name:\'nzc\',age:18}\n    //类比于下面代码\n    let name = \'nzc\';\n    let age = 18;\n```\n\n\n对象嵌套解构\neg：\n\n```\n    let person = { param: [ \'nzc\', { age: 18 } ] };\n    let { param: [name, { age }] } = person; //name=\'nzc\' age=18\n    //类比于下面   param变量被重命名为 [name, { age }],所以自身并未声明;即不存在param变量\n    let { param: [name, { age }] } = { param: [ \'nzc\', { age: 18 } ] }\n```\n\n​    \n默认值(默认值生效的条件是，对象的属性值严格等于undefined)\neg：\n\n```\n    //name=\'nzchs\'->name变量默认值;age:myAge=21->myAge默认值【age重命名为myAge再赋予默认值】\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\',age:18}\n    let {name=\'nzchs\',age:myAge=21} = {name:\'nzc\'}  \n```\n\n\n    \n3、字符串的解构赋值\n解构时，字符串被转换成了一个类似数组的对象。\neg：\n\n```\n    let [a, b, c] = \'hello\'; //a=h;b=e;c=l\n```\n\nlength属性解构\neg：\n\n```\n    let {length : len} = \'hello\'; //len = 5 【匹配右边字符串转换为的类数组对象的length属性并将其值赋值给重命名的len变量】\n```\n\n \n\n\n4、数值和布尔值解构赋值\n解构时，如果等号右边是数值和布尔值，则会先转为相应的基本引用数据类型对象\neg：\n\n```\n    let {toString: str1} = 123; //函数 str1 === Number.prototype.toString     返回true\n    let {toString: str2} = true; //函数 str2 === Boolean.prototype.toString        返回true\n```\n\n\n\n5、函数参数的解构赋值\n基本数组解构赋值传参\neg：\n\n```\n    function add([x, y]){ return x + y; }\n    add([1, 2]);   //函数add返回值为3 \n```\n\n\n函数参数带有默认值\neg：\n\n```\n    function test({x = 0, y = 0}) {\n        return [x, y];\n    }\n    //函数调用\n    test({x: 3, y: 8}); // 返回值为[3, 8]\n    test({x: 3}); // 返回值为[3, 0]\n    test({}); // 返回值为[0, 0]\n    test(); //报错 Cannot destructure property `x` of \'undefined\' or \'null\'\n```\n\n## 三、解构常用用途\n\n1、变量值的交换\neg：\n\n```\n    let x = 1;\n    let y = 2;\n    [x,y] = [y,x];  \n    console.log(x,y); //2 1    \n```\n\n2、函数参数的赋值：\neg：\n\n```\n    //[a=0,b=1] = [1]   a=1,b=1\n    function test([a=0,b=1]){\n        return a+b;\n    }\n    test([1]);  //返回值为2\n```\n\n3、提取对象中的数据\neg：\n\n```\n    let obj= { id: 42, status: \"OK\", data: [867, 5309] };\n    let { id, status, data: number } = obj;  //定义对应的变量 \n```\n\n4、输入模块的指定方法\n\n```\n    const { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n5、遍历map结构\n\n```\n    var map = new Map();\n    map.set(\'name\', \'nzc\');\n    map.set(\'age\', 18);\n    for (let [key, value] of map) {\n        console.log(key + \" is \" + value);    // name is nzc   age is 18\n    }\n```\n\n ', 'ES6中定义变量新增关键字及解构的基本用法', 1584720000000, 986, 2, 1585377428000);
INSERT INTO `article_content` VALUES (34, 'react安装配置（4）', '**一、React安装配置**\r\n\r\n使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速\r\n\r\n1、全局安装最新版本的npm依赖包\r\n\r\n```\r\n$ npm install npm@latest -g\r\n```\r\n\r\n2、安装淘宝镜像【从国内存储库中下载相应的依\r\n\r\n```\r\n$ npm install -g cnpm --registry=[https://registry.npm.taobao.org\r\n```\r\n\r\n3、全局安装脚手架\r\n\r\n```\r\n$ cnpm install -g create-react-app my-app\r\n```\r\n\r\n4、进入项目目录\r\n\r\n```\r\n$ cd my-app\r\n```\r\n\r\n5、启动项目\r\n\r\n```\r\n$ yarn start  或者 cnpm start\r\n```\r\n\r\n\r\n\r\n一些需要的依赖包安装：\r\n\r\n1、安装sass包依赖\r\n\r\n```\r\n$ yarn add sass-loader node-sass --save-dev\r\n```\r\n\r\n2、代码规范配置\r\n\r\n3、安装路由依赖包\r\n\r\n```\r\n$ yarn add react-router-dom --save-dev\r\n```\r\n\r\n4、安装js对象与表单格式的转换依赖包\r\n\r\n```\r\n$ yarn add qs --save-dev\r\n```\r\n\r\n5、安装路由机制依赖包\r\n\r\n```\r\nyarn add react-router-dom --save-dev\r\n```\r\n\r\n从依赖包中导入需要使用的路由相关的变量\r\n\r\n```\r\nImport { HashRouter,NavLink,Switch,Route,Redirect } from ‘react-router-dom’;\r\n```\r\n\r\n设置导航及路由组件：\r\n\r\n```\r\n<HashRouter>\r\n\r\n​    <NavLink activeClassName=\"active\" exact to=\"/\">首页</NavLink>\r\n\r\n​    <NavLink activeClassName=\"active\" to=\"/student\">student</NavLink>\r\n\r\n\r\n\r\n​    <Switch>\r\n\r\n​        <Route exact path=\"/\" component={Index}><Route>\r\n\r\n​        <Route path=\"/student\" component={Student}><Route>\r\n\r\n​        <Route path=“/course“ render(()=>{return <div>course</div>})><Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n\r\n\r\n**二、React框架的三大特点：**\r\n\r\n**1、VRDOM【虚拟dom】**\r\n\r\na、首先构建虚拟DOM树并存储于内存中【具有单页面Web应用的一些优缺点】\r\n\r\nb、在页面数据更新时局部渲染页面【使用diff算法比较页面变化前后的两颗VRDOM树只更新渲染改变的部分（数据更新效率更快）】\r\n\r\n\r\n\r\n**2、组件化 -- JSX语法**\r\n\r\na、函数组件（无状态组件）\r\n\r\nb、class类组件（状态组件）\r\n\r\n容器：不可更改的标签元素，也不能定义为组件【容器若更改，它里面的所有后代元素也会重新渲染（需要定制shouldComponentUpdagte()钩子函数或使用hook），所以一般容器标签元素不可更改】\r\n\r\n\r\n\r\n**3、单向数据流**\r\n\r\n数据只能从父组件向子组件传递数据信息\r\n\r\n**父传子：**\r\n\r\n​    父组件将值作为子组件的属性值传递给子组件\r\n\r\n​    子组件通过this.props.attrName获取相应的值\r\n\r\n\r\n\r\n默认情况下会统一同步，父子数据不想要同步时，将传递给子组件的数据存成子组件的state【在组件挂载前保存更新state数据】\r\n\r\n\r\n\r\n**子传父：**\r\n\r\n​    子组件设置一个函数，在函数内部调用父组件的回调函数（this.props.回调函数名）\r\n\r\n​    父组件中设置一个回调函数传递给子组件并通过该函数获取相应子组件传递过来的参数值。\r\n\r\n\r\n\r\n​    ref属性：【不是特殊情况下，一般不建议使用(它是通过获取标签元素来进行的一些相关操作，与react中的VRDOM有点背道而驰)】\r\n\r\n父组件也可以通过this.refs.子组件ref属性值来获取相应的子组件并可以调用子组件中的状态值。\r\n\r\n\r\n\r\n**三、React中动态传参**\r\n\r\n参考链接：<https://www.jianshu.com/p/77467c15a0ce>\r\n\r\n**1、动态路由传参**【推荐使用】\r\n\r\n```\r\n<Link to=\"/student/sam\">学生</Link>\r\n\r\n//或者\r\n\r\nhashHistory.push(“/user/sam”)\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student/:name\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.match.params.name来获取传递过来的name参数值\r\n\r\n**注：**\r\n\r\n​    该方法可以传递一个或多个值，但值的类型都是字符串【传递一个对象时需要将js对象转换成JSON字符串传递】\r\n\r\n**2、查询字符串传参**【不推荐使用：刷新页面参数丢失】\r\n\r\n```\r\n<NavLink to=“student?name=zhangsan&age=21\"></NavLink>\r\n\r\n\r\n\r\n<HashRouter>\r\n\r\n​    <Switch>\r\n\r\n​        <Route path=\"/student\" component={Student}></Route>\r\n\r\n​    </Switch>\r\n\r\n</HashRouter>\r\n```\r\n\r\n跳转到Student页面时：\r\n\r\n​    使用this.props.location.name\r\n\r\n3、**API传参**【】\r\n\r\n```\r\nthis.props.history.push({\r\n\r\n​    pathname:”/student”,   //跳转的组件路径\r\n\r\n​    payload:”传递的参数\"\r\n\r\n})\r\n\r\nthis.props.location.payload     //获取传递过来的参数数值\r\n```\r\n', '使用脚手架【使用之前确认已安装好node版本>=8.10和npm>=5.6】\r\n\r\n使用npm安装淘宝镜像cnpm在后续安装依赖更加迅速', 1584266350598, 100, 1, 1587644360000);
INSERT INTO `article_content` VALUES (35, 'Redux知识整理（4）', '## 1、创建reducer纯函数【返回最新的状态值state】\n\n创建一个或多个reducer纯函数文件\n\nreducer中设置初始state数据信息\n\n将状态数据state与分发的action对象作为reducer文件中纯函数的两个参数\n\n```\nconst initialState = [];\n\nconst reducer = (state = initialState, action) => {\n\n​    switch() {\n\n​        case ‘reset’:\n\n​            return { ...state, value: action.value };\n\n​        case ‘update’:\n\n​            return Object.assign({}, state, action.payload);\n\n​        default:\n\n​            return state;\n\n​    }\n\n}\n\nexport default reducer;\n```\n\n在获取到分发的action对象匹配对应类型执行相应的业务逻辑处理【更改state中的数据信息】\n\n\n\n## 2、整合reducer\n\n将多个reducer进行整合并可以进行重新命名\n\n```\ncombineReducers({\n\n​    test1:test1Reducer,\n\n​     test2:test2Reducer\n\n})\n```\n\n\n## 3、创建数据源store\n\n将整合的reducer作为createStore()函数的参数创建数据源信息\n\n```\nconst store = createStore(reducer);\n```\n\n**react-redux核心：**<https://www.jianshu.com/p/186956ac666a>\n\n\n\n## 4、Provider组件【容器组件：****负责管理数据和逻辑****】\n\n从react-redux中结构处Provider组件并将其作为整个项目的根元素，将store作为组件的属性向下传递\n\n结合connect函数，后代组件便可以通过props属性获取到store中的数据信息\n\n\n\n## 5、connect函数【连接React组件与Redux store】【展示(UI)组件：****负责 UI 的呈现****】\n\ncoonect函数中的第一个参数包含了原来监听者更新渲染数据的作用【使用connect函数后就不需要再对其另外添加阅读者监听事件渲染更新state】\n\n函数中有两个参数：\n\n参数一:    mapStateToProps函数【将store中的数据作为props绑定到组件上】\n\n```\nmapStateToProps = (state,ownProps)=>{\n\n​    return state;\n\n}\n```\n\n参数二:    mapDispatchTpProps函数【将 action 作为 props 绑定到组件上，也会成为 MyComp 的 props】\n\n```\nmapDispatchToProps = (dispatch,ownProps)=>{    \n\n​    return {\n\n​        changeMsg:()=>{\n\n​            dispatch({\n\n​                type:’CHANGE_MSG’,\n\n​                payload:需要更改的值\n\n​            })\n\n​        }\n\n​    }\n\n}\n```\n\n\n\n## 6、更改或获取store中的state数据\n\n在对应的reducer纯函数中通过分发的action对象执行相应的业务逻辑处理\n\na、判断actiond的type类型，通过action对象中的payload参数信息更新初始state中的数据\n\n\n\n## 7、使用中间件react-thunk或react-saga执行异步请求操作\n\n**在组件js文件中运行相应事件函数分发action**\n\n```\nconst mapDispatchToProps = (dispatch,ownProps) =>{\n\n​    return {\n\n​        getData:()=>{\n\n​            dispatch(getDataAxAction({\n\n​                pageno:1,\n\n​                pagesize:7\n\n​            }));\n\n​        }\n\n​    }\n\n}\n```\n\n**react-thunk：**\n\n在创建store文件中创建thunk中间件\n\n安装react-thunk依赖包：\n\n```\nyarn add react-thunk\n```\n\n**在创建store时编写下面代码**\n\n```\nimport { createStore,applyMiddleware,compose } from \'redux’;\n\nimport thunk from \'redux-thunk’; \n\nimport reducer from \'./reducers’; \n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?       window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; \n\nconst enhancer = composeEnhancers(applyMiddleware(thunk)) \n\nlet store = createStore(reducer,window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); let store = createStore(reducer,enhancer); \n\nexport default store;\n```\n\nreact-thunk异步请求在创建actio文件中创建执行【创建action函数并返回一个函数(可以进行异步请求操作)】\n\n// redux-thunk actionCreator【创建的action函数可以返回一个函数(即可以调用axios执行异步请求数据操作)】\n\n```\nexport const getDataAxAction = (value)=>{   \n\n​    return (dispatch)=>{     \n\n​        axios.get(\'http://134.175.154.93:8099/manager/article/findArticle’, {params:value}).then((res)=>{       \n\n​            //res.data.data.list【获取到查询结果后再次分发action，创建action并将异步请求结果赋值给action.value上】      \n\n​            dispatch(changeArticles(res.data.data.list));     \n\n​        }).catch((error)=>{       \n\n​            console.log(error);     \n\n​        });   \n\n​    }; \n\n}\n```\n\n**react-saga：**\n\n在创建store文件中创建saga中间件\n\n安装react-saga依赖包：\n\n```\n$ yarn add react-saga\n```\n\n在创建store时编写下面代码\n\n```\n// 创建store\nimport { createStore,applyMiddleware,compose } from \'redux’; \nimport reducer from \'./reducers’; \nimport createSagaMiddleware  from \'redux-saga’; \nimport mySagas from \'./mySagas’;\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst sagaMiddleware = createSagaMiddleware(); \n\nconst enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)) \n\nlet store = createStore(reducer,enhancer); \n\n//在这里使用mySagas【在store创建好后，中间件挂好后在使用mySagas】 \n\nsagaMiddleware.run(mySagas);\n\nexport default store;\n```\n\n创建mySagas文件：【组件分发相应的action，mysaga中间件文件根据actionType匹配相应的action执行异步请求后，再次分发action对象，在reducer文件中同步请求更改store中的状态数据】\n\n```\nimport { takeEvery,put } from ‘redux-saga/effects’;\n\n//创建mySagas【generator函数】函数后，在创建store仓库中使用mySagas【saga中间插件调用run方法使用】\nfunction* mySagas(){   // console.log(11111);   \n​    //监听某个action,然后执行第二个参数gengerator函数   \n​    yield takeEvery(GET_DATA_SA_ACTION,getList);   \n}\n\n//参数action就是对应的action对象 \nfunction* getList(action){   \n​    //发送异步，异步成功后分发action   \n​    let res = yield axios.get(url,   {params:action.value});   \n​    //put就是转发action，类似于dispatch，然后执行同步请求执行相应的业务逻辑处理   \n​    yield put(changeArticles(res.data.list)); \n}\n```\n\n', '前端状态数据管理库redux结合react-thunk或react-saga中间件的基本使用', 1584266350598, 242, 1, 1584266350598);
COMMIT;

-- ----------------------------
-- Table structure for article_type
-- ----------------------------
DROP TABLE IF EXISTS `article_type`;
CREATE TABLE `article_type` (
  `id` int(11) NOT NULL,
  `typeName` varchar(255) DEFAULT NULL,
  `orderNum` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_type
-- ----------------------------
BEGIN;
INSERT INTO `article_type` VALUES (3, 'react', 0);
INSERT INTO `article_type` VALUES (2, 'css', 1);
INSERT INTO `article_type` VALUES (1, 'js', 2);
INSERT INTO `article_type` VALUES (1, 'React', 1);
INSERT INTO `article_type` VALUES (2, 'JS', 2);
INSERT INTO `article_type` VALUES (3, 'ES6', 3);
INSERT INTO `article_type` VALUES (4, 'Other', 4);
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `articleId` int(3) NOT NULL,
  `content` varchar(255) DEFAULT NULL,
  `release_time` bigint(13) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `phone` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES (3, 3, '留言test', 1585119329391, 'jack', '2425796538@qq.com');
INSERT INTO `comment` VALUES (4, 7, '留言信息内容！', 1587717166349, 'Tom', '2638278920@qq.com');
INSERT INTO `comment` VALUES (5, 7, '留言信息内容！！  你好', 1587717205551, 'Tom', '2638278920@qq.com');
INSERT INTO `comment` VALUES (6, 7, 'test留言信息', 1587717253703, 'Tom', '2638278920@qq.com');
COMMIT;

-- ----------------------------
-- Table structure for userinfo
-- ----------------------------
DROP TABLE IF EXISTS `userinfo`;
CREATE TABLE `userinfo` (
  `userName` varchar(255) DEFAULT NULL,
  `nickName` varchar(255) DEFAULT NULL,
  `introduce` varchar(255) DEFAULT NULL,
  `github` varchar(255) DEFAULT NULL,
  `blog` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `wechat` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `id` int(2) NOT NULL AUTO_INCREMENT,
  `password` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of userinfo
-- ----------------------------
BEGIN;
INSERT INTO `userinfo` VALUES ('0173948', '我', '一只会看书的狗狗', 'https://github.com/xu-126', 'https://juejin.cn/', '1264930795', 'tianhenlan126', 'http://127.0.0.1:7001/public/uploads/86db68340670b0cfa4e31c33a99c922e.png', 1, '123');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
